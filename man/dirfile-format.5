.\" dirfile-format.5.  The dirfile format file man page.
.\"
.\" (C) 2005, 2006, 2008 D. V. Wiebe
.\"
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\"
.\" This file is part of the GetData project.
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" GetData is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\" General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License along
.\" with GetData; if not, write to the Free Software Foundation, Inc.,
.\" 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
.\"
.TH dirfile\-format 5 "21 October 2008" "Standards Version 6" "DATA FORMATS"
.SH NAME
dirfile\-format \(em the dirfile database format specification file
.SH DESCRIPTION
The
.I dirfile format
file fully specifies the raw and derived time streams and auxiliary information
for a
.BR dirfile (5)
database.

The format file is a case sensitive text file called
.B format
located in the dirfile directory.  The explicit text encoding of the file is not
specified by these standards, but must be 7-bit ASCII compatible. Examples of
acceptable character encodings include all the ISO\~8859 character sets
.RI ( i.e.
Latin-1 through Latin-10, among others), as well as the UTF-8 encoding of
Unicode and UCS.

.SH SYNTAX
The format file is composed of field specification lines and directive lines,
optionally separated by blank lines or lines containing only whitespace.
Lines are separated by the line-feed character (0x0A).  Unless escaped (see
below), the hash mark
.RB ( # )
is the comment delimiter; the comment delimiter, and any text following it to
the end of the line, is ignored.

.SS Tokens
Both field specification lines and directive lines consist of several tokens
separated by whitespace.  Whitespace consists of one or more whitespace
characters.  These are: space (0x20), horizontal tab (0x09), vertical tab
(0x0B), form-feed (0x0C), and carriage return (0x0D).  The first token of a
directive line is always a
.IR "reserved word" .
The first token of a field specification line is never a reserved word.

Since tokens are separated by whitespace, to include a whitespace character in
a token, it must either escaped by preceding it by a backslash character
.RB ( \e ),
or be replaced by a
.I character escape sequence
(see below), or else the token must be enclosed in quotation marks
.RB ( """" ).
The quotation marks themselves will be stripped from the token. The
.I null-token
(that is, the token consisting of zero characters) may be specified by a pair
of quotation marks with nothing between them
.RB ( """""" ).
To include a literal quotation mark in a token, it must be escaped
.RB ( \e" ).
Similarly, a hash mark may be included in a token by including it in a quoted
token or else by escaping it
.RB ( \e# ),
otherwise the hash mark will be understood as the comment delimiter.

It is a syntax error to have a line which contains unmatched quotation marks, or
in which the last character is the backslash character.

Several characters when escaped by a preceding backslash character are
interpreted as special characters in tokens.  Some of these have already been
mentioned.  The character escape sequences are:
.RS
.TP
.BR \e\~\~ (i.e.\~backslash-space)
a space character (ASCII 0x20 / U+0020)
.TP
.B \e"
a quotation mark character (ASCII 0x22 / U+0022)
.TP
.B \e#
a hash mark character (ASCII 0x23 / U+0023)
.TP
.B \ea
an alert (bell) character (ASCII 0x07 / U+0007)
.TP
.B \eb
a backspace character (ASCII 0x08 / U+0008)
.TP
.B \ee
an escape character (ASCII 0x1B / U+001B)
.TP
.B \ef
a form-feed character (ASCII 0x0C / U+000C)
.TP
.B \en
a line-feed character (ASCII 0x0A / U+000A)
.TP
.B \er
a carriage return character (ASCII 0x0D / U+000D)
.TP
.B \et
a horizontal tab character (ASCII 0x09 / U+0009)
.TP
.B \ev
a vertical tab character (ASCII 0x0B / U+000B)
.TP
.B \e\e
a backslash character (ASCII 0x5C / U+005C)
.TP
.BI \e ooo
the single byte given by the octal number
.IR ooo .
.TP
.BI \ex hh
the single byte given by the hexadecimal number
.IR hh .
.TP
.BI \eu hhhhhhh
the UTF-8 byte sequence encoding the Unicode code point given by the hexadecimal
number
.IR hhhhhhh .
.RE

Any other character which is escaped is interpreted as the character itself.
.RI ( i.e.
.B \ec
is interpreted as
.BR c ).

No token may contain the NULL character (ASCII 0x00 / U+0000).  Furthermore,
although support is present to create UTF-8 byte sequences, tokens are not
required to be valid UTF-8 sequences.  Any byte sequence not containing the NULL
character forms a valid token.  However, there may be further restrictions on
allowed characters for a token in a particular situation, (for example, when
used as a field name).

.SS Directives

There are eight 
.IR "reserved words" ,
which cannot be used as field names in the dirfile.  Instead, these specify
directives.  Any reserved word may omit its initial forward slash
.RB ( / ),
without change in meaning.  Future versions of the Standards may require the
slash to distinguish a reserved word from a field name.  Like the rest of the
format file, directives are case sensitive.

A number of the directives have
.IR "fragment scope" .
A directive with fragment scope only applies to the fragment in which it is
present, plus any sub-fragments indicated by the
.B /INCLUDE
directive, but only if those sub-fragments don't have their own corresponding
directive.  Directives which have fragment scope are:
.BR /ENCODING ,\~ /ENDIAN ,\~ /FRAMEOFFSET ", and " /PROTECT .
Becase of these scoping rules, different portions of the dirfile may have
different encodings, endiannesses, frame offsets, or protection levels.

If a directive with fragment scope appears more than once in a fragment, only
the last such directive will be honoured, with the exception that the effect of
a directive will not be propagated to sub-fragments if the directive line
appears after the sub-fragment is included.  The scoping rules of the remaining
directives are discussed below.

.TP
.B /ENCODING
The ENCODING directive specifies the encoding scheme used to encode binary
files in the dirfile.  The encoding scheme may be one of the predefined names
listed below, which are described in more detail in
.BR dirfile-encoding (5),
or any other site-specific encoding scheme.  The predefined scheme names are:
.RS
.TP
.I none
The dirfile is unencoded.
.TP
.I slim
The dirfile is compressed using the slimlib library.
.TP
.I text
The dirfile is text encoded.
.PP
Implementations should fail gracefully when encountering an unknown encoding
scheme.  If no encoding scheme is specified, behaviour is implementation
dependent.  Syntax is:
.IP
.BI /ENCODING\~ <scheme>
.PP
The ENCODING directive has
.IR "fragment scope" .
.RE
.TP
.B /ENDIAN
The ENDIAN directive specifies the endianness of the raw data in the database.
In previous versions of the Dirfile Standard, raw data was always assumed to be
little-endian.  This assumption has been removed.  The assumed endianness of raw
data in dirfiles which omit this directive is implementation dependent.  Syntax
is:
.RS
.IP
.B /ENDIAN
.IR "( " big " | " little " )"
.PP
The ENDIAN directive has
.IR "fragment scope" .
.RE
.TP
.B /FRAMEOFFSET
The FRAMEOFFSET directive specifies the frame number of the first frame in the
database.  Syntax is:
.RS
.IP
.BI /FRAMEOFFSET\~ <integer>
.PP
The FRAMEOFFSET directive has
.IR "fragment scope" .
.RE
.TP
.B /INCLUDE
The INCLUDE directive specifies another file (called a
.IR "format file fragment" )
to parse for additional format specification for the dirfile.  The inclusion is
treated as if the lines of the fragment were pasted verbatim in place of the
INCLUDE directive line.  The exception to this is that RAW fields specified in
the fragment are located in the directory containing the fragment and not in the
directory containing the parent format file, and the binary file encoding may be
different for each fragment.  The fragment may be specified either with an
absolute path, or else a relative path from the current file.  Syntax is:
.RS
.IP
.BI /INCLUDE\~ <file>
.PP
The INCLUDE directive has no scope: it is processed immediately and has no
long-term effect.
.RE
.TP
.B /META
The META directive specifies a metafield attached to a particular parent
field.  The field metadata may be of any allowed type except
.BR RAW .
Metafields are retrieved in exactly the same way as regular field data, but the
field code specified consists of the parent and metafield names joined with
a forward slash:
.RS
.IP
.IB <parent-field> / <meta-field>
.PP
META fields may not be specified before their parent field has been.  Syntax is:
.IP
.B /META
.I <parent-field>
{field specification line}
.PP
As an illustration of this concept,
.IP
.B /META 
pfield meta
.B CONST FLOAT64
3.291882
.PP
provides a scalar metadatum called
.I meta
with value 3.291882 attached to the field
.IR pfield .
This particular metafield may be referred to by the field code
"pfield/meta".  Note that different parent fields may have metafields with
the same name, since all references to metafields must include the parent
field name.  Metafields may not themselves have further sub-metafields.
.PP
The META directive has no scope: it is processed immediately and has no
long-term effect.
.RE
.TP
.B /PROTECT
The PROTECT directive specifies the advisory protection level of the current
fragment and of the
.B RAW
fields defined therein.  The protection level indicates whether writing to the
format file fragment, or the binary data on disk is permitted.  Syntax is:
.RS
.IP
.BI /PROTECT\~ <level>
.PP
Four advisory protection levels are defined:
.TP
.I none
No protection at all: data and metadata may be freely changed.  This is the
default, if no PROTECT directive is present.
.TP
.I format
The dirfile metadata is protected from change, but
.B RAW
data on disk may be modified.
.TP
.I data
The
.B RAW
data on disk is protected from change, but metadata may be modified.
.TP
.I all
Both metadata and data on disk are protected from change.
.PP
The PROTECT directive has
.IR "fragment scope" .
.RE
.TP
.B /REFERENCE
The REFERENCE directive specifies the name of the field to use as the dirfile's
reference field (see
.BR dirfile (5)).
If no REFERENCE directive is specified, the first
.B RAW
field encountered is used as the reference field.  The REFERENCE directive must
specify a
.B RAW
field.  Syntax is:
.RS
.IP
.BI /REFERENCE\~ <field-code>
.PP
The REFERENCE directive has
.IR "global scope" :
if multiple REFERENCE directives appear in the dirfile metadata, only the last
such will be honoured.
.RE
.TP
.B /VERSION
The VERSION directive specifies the particular version of the Dirfile Standards
to which the dirfile format file conforms.  This directive should occur before
any version dependent syntax is encountered.  As of Standards Version 6, no such
syntax exists, and this directive is provided primarily to ease forward
compatibility.  Syntax is:
.RS
.IP
.BI /VERSION\~ <integer>
.PP
The VERSION directive has
.IR "immediate scope" :
its effect is immediate, and it applies only to metadata below it, including
and propagating downwards to sub-fragments after the directive.  Its effect
will also propagate upwards back to the parent fragment, and affect subsequent
metadata.
.RE

.SS Field Specification Lines

Any line which does not start with a
.I reserved word
is assumed to be a field specification line.  The first token in a field
specification line is the field name.  The field name consists of one or more
characters, excluding both ASCII control characters, and the characters
.IP
.B &\t/\t;\t<\t>\t|\t.
.PP
which are reserved.  The field name may not be
.I INDEX
which is a special, implicit field which contains the integer frame index.
Field names are case sensitive.  The second token in the field specification
line is the field type.  The meaning of subsequent tokens depends on the field
type.

Some of the parameters in a field specification line may be either literal
numbers or else the field code of a
.B CONST
field containing the number.  Such parameters are indicated below.  Since it is
possible to create a field code which is identical to a literal number, a
parameter is assumed to be the field code of a 
.B CONST
field only if the entire token cannot be parsed as a literal number using the
rules outlined in
.BR strtod (3).
(So, for example, a
.B CONST
field whose field code consists solely of digits can never be used as a
parameter in a field specification line.)

There are eight field types.  Of these, six are of vector type
.RB ( BIT ", " LINCOM ", " LINTERP ", " MULTIPLY ", " PHASE ", and " RAW )
and two are of scalar type
.RB ( CONST " and " STRING ).
The possible fields types are:
.TP
.B BIT
The BIT vector field type extracts one or more bits out of an input vector
field.  Syntax is:
.RS
.IP
.I <field-name>
.B BIT
.I <input> <first-bit> [<bits>]
.PP
which specifies
.I field-name
to be the value of bits
.I first-bit
through
.IR first-bit + bits -1
of the input vector field
.IR input ,
when
.I input
is converted from its native type to an (endianness corrected) unsigned 64-bit
integer.  If
.I bits
is omitted, it is assumed to be 1.  Both
.IR first-bit " and " bits
may be either literal numbers, or else the field code of a
.B CONST
field type containing their values.
.RE
.TP
.B CONST
The CONST scalar field type is a constant fully specified in the format file
metadata.  Syntax is:
.RS
.IP
.I <field-name>
.B CONST
.I <type> <value>
.PP
where
.I type
may be any supported native data type (see the description of the
.B RAW
field type below), and
.I value
is the numerical value of the constant interpreted as indicated by
.IR type .
.RE
.TP
.B LINCOM
The LINCOM vector field type is the linear combination of one, two or three
input vector fields.  Syntax is:
.RS
.IP
.I <field-name>
.B LINCOM
.IR "<n> <field1> <a1> <b1>"\~ [ "<field2> <a2> <b2>"\~ [ "<field3> <a3> <b3>" ]]
.PP
where
.I n
indicates the number of input vector fields (1, 2, or 3).  The derived field
will be computed as:
.IP
field-name[n] = (a1 * field1[n] + b1) + (a2 * field2[n2] + b2) + (a3 * field3[n3] + b3)
.PP
with the
.I field2
and
.I field3
terms included only if specified and the indices
.I n2
and
.I n3
computed appropriately for the (potentially differing) sample rates of the
input fields.  The resultant field will have the same sample rate as
.IR field1 .
Each supplied co-efficient
.RI ( a1 ,\~ b1 ,\~ a2 ,
&c.) may be either a literal number, or else the field code of a
.B CONST
field type containing its value.
.RE
.TP
.B LINTERP
The LINTERP vector field type specifies a table look up based on another vector
field.  Syntax is:
.RS
.IP
.I <field-name>
.B LINTERP
.I <input> <table>
.PP
where
.I input
is the input vector field for the table lookup and
.I table
is the complete path to the lookup table file for the field.  The lookup table
file is an ASCII text file with two whitespace separated columns of
.I x
and
.I y
values.  Values are linearly interpolated between the points specified in the
lookup table.
.RE
.TP
.B MULTIPLY
The MULTIPLY vector field type is the product of two vector fields.  Syntax is:
.RS
.IP
.I <field-name>
.B MULTIPLY
.I <field1> <field2>
.PP
The derived field will be computed as:
.IP
field-name[n] = field1[n] * field2[n2]
.PP
with the index
.I n2
computed appropriately for the (potentially differing) sample rates of the
input fields.  The resultant field will have the same sample rate as
.IR field1 .
.RE
.TP
.B PHASE
The PHASE vector field type shifts an input vector field by the specified number
of samples.  Syntax is:
.RS
.IP
.I <field-name>
.B PHASE
.I <input> <shift>
.PP
which specifies
.I field-name
to be the input vector field,
.IR input ,
shifted by
.I shift
samples.  A positive
.I shift
indicates a shift forward in time.  Results of shifting past the beginning- or
end-of-file is implementation dependent.  The
.I shift
parameter may be either a literal number, or else the field code of a
.B CONST
field type containing its values.
.RE
.TP
.B RAW
The RAW vector field type specifies raw time streams on disk.  In this case, the
field name should correspond to the name of the file containing the time stream.
Syntax is:
.RS
.IP
.I <field-name>
.B RAW
.I <type> <sample-rate>
.PP
where
.I sample-rate
is the number of samples per dirfile frame for the time stream and
.I type
is a token specifying the native data format type:
.RS
.TP
.I UINT8
unsigned 8-bit integer
.TP
.I INT8
signed 8-bit integer
.TP
.I UINT16
unsigned 16-bit integer
.TP
.I INT16
signed 16-bit integer
.TP
.I UINT32
unsigned 32-bit integer
.TP
.I INT32
signed 32-bit integer
.TP
.I UINT64
unsigned 64-bit integer
.TP
.I INT64
signed 64-bit integer
.TP
.IR FLOAT32 \~or\~ FLOAT
IEEE-754 standard 32-bit single precision floating point number
.TP
.IR FLOAT64 \~or\~ DOUBLE
IEEE-754 standard 64-bit double precision floating point number
.RE

For backwards compatibility, implementations should also recognise the following
single character type aliases in use prior to Standards Version 5:
.RS
.TP
.I c
UINT8
.TP
.I u
UINT16
.TP
.I s
INT16
.TP
.I U
UINT32
.TP
.IR i ,\~ S
INT32
.TP
.IR f
FLOAT32
.TP
.IR d
FLOAT64
.RE

Types
.IR INT8 ,\~ UINT64 ,
and
.I INT64
are not supported before Standards Version 5, so no single character type
aliases exist for these types.

The
.I sample-rate
parameter may be either a literal number, or else the name of a
.B CONST
field type containing its values.
.RE
.TP
.B STRING
The STRING scalar field type is a character string fully specified in the format
file metadata.  Syntax is:
.RS
.IP
.I <field-name>
.B STRING
.I <value>
.PP
where
.I value
is the string value of the field.  Note that
.I value
is a single token.  To include whitespace in the string, enclose
.I value
in quotation marks
.RB ( """" ),
or else escape the whitespace with the backslash character
.RB ( \e ).
.RE

.SH STANDARDS VERSIONS

This document describes Version 6 of the Dirfile Standards.

Version 6 of the Standards (October 2008) added the
.BR /ENCODING ,\~ /META ,\~ /PROTECT ", and " /REFERENCE
directives, and the
.B CONST
and
.B STRING
field types.  It permitted whitespace in tokens and introduced the character
escape sequences. It allowed
.B CONST
fields to be used as parameters in field specification lines.  It also removed
.I FILEFRAM
as an alias for
.IR INDEX ,
and allowed '#' and '\e' in field codes.

Version 5 of the Standards (August 2008) added
.B /VERSION
and
.BR /ENDIAN ,
slash demarcation of reserved words, and removed the restriction on field
name length.  It introduced the data types
.IR INT8 ,\~ INT64 ,
and
.IR UINT64 ,
the new-style type specifiers, and increased the range of the
.B BIT
field type from 32 to 64 bits.  It also prohibited the characters
.B #&/;<>\e.|
in field codes.

Version 4 of the Standards (October 2006) added the
.B PHASE
field type.

Version 3 of the Standards (January 2006) added
.B INCLUDE 
and increased the allowed length of a field name from 16 to 50 characters.

Version 2 of the Standards (September 2005) added the
.B MULTIPLY
field type.

Version 1 of the Standards (November 2004) added
.B FRAMEOFFSET
and the optional fourth argument to the
.B BIT
field type.

Version 0 of the Standards (before March 2003) refers to the dirfile standards
supported by the
.BR getdata (3)
library originally introduced into the
.BR kst (1)
sources, which contained support for all other features covered by this
document.

.SH AUTHORS

The dirfile specification was developed by C. B. Netterfield
.nh
<netterfield@astro.utoronto.ca>
.hy 1

Since Standards Version 3, the dirfile specification has been maintained by
D. V. Wiebe
.nh
<dwiebe@physics.utoronto.ca>
.hy 1

.SH SEE ALSO
.BR dirfile (5),
.BR dirfile-encoding (5)
