.\" dirfile-format.5.  The dirfile format file man page.
.\"
.\" (C) 2005, 2006, 2008, 2009 D. V. Wiebe
.\"
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\"
.\" This file is part of the GetData project.
.\"
.\" Permission is granted to copy, distribute and/or modify this document
.\" under the terms of the GNU Free Documentation License, Version 1.2 or
.\" any later version published by the Free Software Foundation; with no
.\" Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
.\" Texts.  A copy of the license is included in the `COPYING.DOC' file
.\" as part of this distribution.
.\"
.TH dirfile\-format 5 "19 October 2009" "Standards Version 7" "DATA FORMATS"
.SH NAME
dirfile\-format \(em the dirfile database format specification file
.SH DESCRIPTION
The
.I dirfile format
file fully specifies the raw and derived time streams and auxiliary information
for a
.BR dirfile (5)
database.

The format file is a case sensitive text file called
.B format
located in the dirfile directory.  The explicit text encoding of the file is not
specified by these standards, but must be 7-bit ASCII compatible. Examples of
acceptable character encodings include all the ISO\~8859 character sets
.RI ( i.e.
Latin-1 through Latin-10, among others), as well as the UTF-8 encoding of
Unicode and UCS.

.SH SYNTAX
The format file is composed of field specification lines and directive lines,
optionally separated by blank lines or lines containing only whitespace.
Lines are separated by the line-feed character (0x0A).  Unless escaped (see
below), the hash mark
.RB ( # )
is the comment delimiter; the comment delimiter, and any text following it to
the end of the line, is ignored.

.SS Tokens
Both field specification lines and directive lines consist of several tokens
separated by whitespace.  Whitespace consists of one or more whitespace
characters.  These are: space (0x20), horizontal tab (0x09), vertical tab
(0x0B), form-feed (0x0C), and carriage return (0x0D).  The first token of a
directive line is always a
.IR "reserved word" .
The first token of a field specification line is never a reserved word.  Any
amount of whitespace may precede the first token on a line.

Since tokens are separated by whitespace, to include a whitespace character in
a token, it must either escaped by preceding it by a backslash character
.RB ( \e ),
or be replaced by a
.I character escape sequence
(see below), or else the token must be enclosed in quotation marks
.RB ( """" ).
The quotation marks themselves will be stripped from the token. The
.I null-token
(that is, the token consisting of zero characters) may be specified by a pair
of quotation marks with nothing between them
.RB ( """""" ).
To include a literal quotation mark in a token, it must be escaped
.RB ( \e" ).
Similarly, a hash mark may be included in a token by including it in a quoted
token or else by escaping it
.RB ( \e# ),
otherwise the hash mark will be understood as the comment delimiter.

It is a syntax error to have a line which contains unmatched quotation marks, or
in which the last character is the backslash character.

Several characters when escaped by a preceding backslash character are
interpreted as special characters in tokens.  The character escape sequences
are:
.RS
.TP
.B \ea
an alert (bell) character (ASCII 0x07 / U+0007)
.TP
.B \eb
a backspace character (ASCII 0x08 / U+0008)
.TP
.B \ee
an escape character (ASCII 0x1B / U+001B)
.TP
.B \ef
a form-feed character (ASCII 0x0C / U+000C)
.TP
.B \en
a line-feed character (ASCII 0x0A / U+000A)
.TP
.B \er
a carriage return character (ASCII 0x0D / U+000D)
.TP
.B \et
a horizontal tab character (ASCII 0x09 / U+0009)
.TP
.B \ev
a vertical tab character (ASCII 0x0B / U+000B)
.TP
.B \e\e
a backslash character (ASCII 0x5C / U+005C)
.TP
.BI \e ooo
the single byte given by the octal number
.IR ooo .
.TP
.BI \ex hh
the single byte given by the hexadecimal number
.IR hh .
.TP
.BI \eu hhhhhhh
the UTF-8 byte sequence encoding the Unicode code point given by the hexadecimal
number
.IR hhhhhhh .
.RE

Any other character which is escaped is interpreted as the character itself.
.RI ( i.e.
.B \ec
is interpreted as
.BR c ).

No token may contain the NULL character (ASCII 0x00 / U+0000).  Furthermore,
although support is present to create UTF-8 byte sequences, tokens are not
required to be valid UTF-8 sequences.  Any byte sequence not containing the NULL
character forms a valid token.  However, there may be further restrictions on
allowed characters for a token in a particular situation, (for example, when
used as a field name).

.SH DIRECTIVES

There are eight 
.IR "reserved words" ,
which cannot be used as field names in the dirfile.  Instead, these specify
directives.  Any reserved word may omit its initial forward slash
.RB ( / ),
without change in meaning.  Future versions of the Standards may require the
slash to distinguish a reserved word from a field name.  Like the rest of the
format file, directives are case sensitive.

A number of the directives have
.IR "fragment scope" .
A directive with fragment scope only applies to the fragment in which it is
present, plus any sub-fragments indicated by the
.B /INCLUDE
directive, but only if those sub-fragments don't have their own corresponding
directive.  Directives which have fragment scope are:
.BR /ENCODING ,\~ /ENDIAN ,\~ /FRAMEOFFSET ", and " /PROTECT .
Because of these scoping rules, different portions of the dirfile may have
different encodings, endiannesses, frame offsets, or protection levels.

If a directive with fragment scope appears more than once in a fragment, only
the last such directive will be honoured, with the exception that the effect of
a directive will not be propagated to sub-fragments if the directive line
appears after the sub-fragment is included.  The scoping rules of the remaining
directives are discussed below.

.TP
.B /ENCODING
The ENCODING directive specifies the encoding scheme used to encode binary
files in the dirfile.  The encoding scheme may be one of the predefined names
listed below, which are described in more detail in
.BR dirfile\-encoding (5),
or any other site-specific encoding scheme.  The predefined scheme names are:
.RS
.TP
.I none
The dirfile is unencoded.
.TP
.I bzip2
The dirfile is compressed using the bzip2 compression scheme.
.TP
.I gzip
The dirfile is compressed using the gzip compression scheme.
.TP
.I lzma
The dirfile is compressed using the LZMA compression scheme.
.TP
.I slim
The dirfile is compressed using the slim compression scheme.
.TP
.I text
The dirfile is text encoded.
.PP
Implementations should fail gracefully when encountering an unknown encoding
scheme.  If no encoding scheme is specified, behaviour is implementation
dependent.  Syntax is:
.IP
.BI /ENCODING\~ <scheme>
.PP
The ENCODING directive has
.IR "fragment scope" .
.RE
.TP
.B /ENDIAN
The ENDIAN directive specifies the endianness of the raw data in the database.
In previous versions of the Dirfile Standard, raw data was always assumed to be
little-endian.  This assumption has been removed.  The assumed endianness of raw
data in dirfiles which omit this directive is implementation dependent.  Syntax
is:
.RS
.IP
.B /ENDIAN
.IR "( " big " | " little " )"
.PP
The ENDIAN directive has
.IR "fragment scope" .
.RE
.TP
.B /FRAMEOFFSET
The FRAMEOFFSET directive specifies the frame number of the first frame for
which data exists in binary files associated with
.B RAW
fields.  Syntax is:
.RS
.IP
.BI /FRAMEOFFSET\~ <integer>
.PP
The FRAMEOFFSET directive has
.IR "fragment scope" .
.RE
.TP
.B /INCLUDE
The INCLUDE directive specifies another file (called a
.IR "format file fragment" )
to parse for additional format specification for the dirfile.  The inclusion is
treated as if the lines of the fragment were pasted verbatim in place of the
INCLUDE directive line.  The exception to this is that RAW fields specified in
the fragment are located in the directory containing the fragment and not in the
directory containing the parent format file, and the binary file encoding may be
different for each fragment.  The fragment may be specified either with an
absolute path, or else a relative path from the current file.  Syntax is:
.RS
.IP
.BI /INCLUDE\~ <file>
.PP
The INCLUDE directive has no scope: it is processed immediately and has no
long-term effect.
.RE
.TP
.B /META
The META directive specifies a metafield attached to a particular parent
field.  The field metadata may be of any allowed type except
.BR RAW .
Metafields are retrieved in exactly the same way as regular field data, but the
.I field code
specified consists of the parent and metafield names joined with a forward
slash:
.RS
.IP
.IB <parent-field> / <meta-field>
.PP
META fields may not be specified before their parent field has been.  Syntax is:
.IP
.B /META
.I <parent-field>
{field specification line}
.PP
As an illustration of this concept,
.IP
.B /META 
pfield meta
.B CONST FLOAT64
3.291882
.PP
provides a scalar metadatum called
.I meta
with value 3.291882 attached to the field
.IR pfield .
This particular metafield may be referred to by the
.I field code
"pfield/meta".  Note that different parent fields may have metafields with
the same name, since all references to metafields must include the parent
field name.  Metafields may not themselves have further sub-metafields.
.PP
As an alternative to the META directive, a metafield may be specified by a
standard field specification line, using
.IP
.IB <parent-field> / <meta-field>
.PP
as the field name.  That is, the above example metafield could have also been
specified as:
.IP
pfield/meta
.B CONST FLOAT64
3.291882
.PP
The META directive has no scope: it is processed immediately and has no
long-term effect.
.RE
.TP
.B /PROTECT
The PROTECT directive specifies the advisory protection level of the current
fragment and of the
.B RAW
fields defined therein.  The protection level indicates whether writing to the
format file fragment, or the binary data on disk is permitted.  Syntax is:
.RS
.IP
.BI /PROTECT\~ <level>
.PP
Four advisory protection levels are defined:
.TP
.I none
No protection at all: data and metadata may be freely changed.  This is the
default, if no PROTECT directive is present.
.TP
.I format
The dirfile metadata is protected from change, but
.B RAW
data on disk may be modified.
.TP
.I data
The
.B RAW
data on disk is protected from change, but metadata may be modified.
.TP
.I all
Both metadata and data on disk are protected from change.
.PP
The PROTECT directive has
.IR "fragment scope" .
.RE
.TP
.B /REFERENCE
The REFERENCE directive specifies the name of the field to use as the dirfile's
reference field (see
.BR dirfile (5)).
If no REFERENCE directive is specified, the first
.B RAW
field encountered is used as the reference field.  The REFERENCE directive must
specify a
.B RAW
field.  Syntax is:
.RS
.IP
.BI /REFERENCE\~ <field-code>
.PP
The REFERENCE directive has
.IR "global scope" :
if multiple REFERENCE directives appear in the dirfile metadata, only the last
such will be honoured.
.RE
.TP
.B /VERSION
The VERSION directive specifies the particular version of the Dirfile Standards
to which the dirfile format file conforms.  This directive should occur before
any version dependent syntax is encountered.  As of Standards Version 6, no such
syntax exists, and this directive is provided primarily to ease forward
compatibility.  Syntax is:
.RS
.IP
.BI /VERSION\~ <integer>
.PP
The VERSION directive has
.IR "immediate scope" :
its effect is immediate, and it applies only to metadata below it, including
and propagating downwards to sub-fragments after the directive.  Its effect
will also propagate upwards back to the parent fragment, and affect subsequent
metadata.
.RE

.SH FIELD SPECIFICATION LINES

Any line which does not start with a
.I reserved word
is assumed to be a field specification line.  A field specification line
consists of at least two tokens.  The first token is the
.IR "field name" .
The second token is the
.IR "field type" .
Subsequent tokens are field parameters.  The meaning and number these parameters
depends on the field type specified.

.SS Field Names
The first token in a field
specification line is the field name.  The field name consists of one or more
characters, excluding both ASCII control characters (the bytes 0x01 through
0x1F), and the characters
.IP
.B &\t/\t;\t<\t>\t|\t.
.PP
which are reserved (but see below for the use of
.B /
to specify metafields).  The field name may not be
.IR INDEX ,
which is a special, implicit field which contains the integer frame index.
Field names are case sensitive.

If the field name beginning a field specifiction line does contain a
.B /
character, the line is assumed to specify a metafield.  See the
.B META
directive above for further details.

.SS Field Types
There are ten field types.  Of these, eight are of vector type
.RB ( BIT ", " LINCOM ", " LINTERP ", " MULTIPLY ", " PHASE ,
.BR POLYNOM ", " RAW ", and " SBIT )
and two are of scalar type
.RB ( CONST " and " STRING ).
The possible fields types are:
.TP
.B BIT
The BIT vector field type extracts one or more bits out of an input vector
field as an unsigned number.  Syntax is:
.RS
.IP
.I <field-name>
.B BIT
.I <input> <first-bit> [<bits>]
.PP
which specifies
.I field-name
to be the value of bits
.I first-bit
through
.IR first-bit + bits -1
of the input vector field
.IR input ,
when
.I input
is converted from its native type to an (endianness corrected) unsigned 64-bit
integer.  If
.I bits
is omitted, it is assumed to be 1.  Both
.IR first-bit " and " bits
may be either literal numbers, or else the field code of a
.B CONST
field type containing their values.  The
.B SBIT
field type is a signed version of this field type.
.RE
.TP
.B CONST
The CONST scalar field type is a constant fully specified in the format file
metadata.  Syntax is:
.RS
.IP
.I <field-name>
.B CONST
.I <type> <value>
.PP
where
.I type
may be any supported native data type (see the description of the
.B RAW
field type below), and
.I value
is the numerical value of the constant interpreted as indicated by
.IR type .
.RE
.TP
.B LINCOM
The LINCOM vector field type is the linear combination of one, two or three
input vector fields.  Syntax is:
.RS
.IP
.I <field-name>
.B LINCOM
.RI [ <n> "] " "<field1> <a1> <b1>"\~ [ "<field2> <a2> <b2>"\~ [ "<field3> <a3>"
.IR <b3> ]]
.PP
where
.IR n ,
if present, indicates the number of input vector fields (1, 2, or 3).  The
derived field will be computed as:
.IP
field-name[n] = (a1 * field1[n] + b1) + (a2 * field2[n2] + b2) + (a3 * field3[n3] + b3)
.PP
with the
.I field2
and
.I field3
terms included only if specified and the indices
.I n2
and
.I n3
computed appropriately for the (potentially differing) sample rates of the
input fields.  The resultant field will have the same sample rate as
.IR field1 .
Each supplied co-efficient
.RI ( a1 ,\~ b1 ,\~ a2 ,
&c.) may be either a literal number, or else the field code of a
.B CONST
field type containing its value.

If
.I n
is not specified, the number of fields is determined by looking at the supplied
parameters.  Since it is possible to create a field code which is identical to
a literal number, the third token on the line is assumed to be
.I n
if it the entire token can be parsed as a literal number using the rules
outlined in
.BR strtod (3).
That is, if the field code specifying
.I field1
could be mistaken for a literal number,
.I n
must be specified to prevent ambiguity.
.RE
.TP
.B LINTERP
The LINTERP vector field type specifies a table look up based on another vector
field.  Syntax is:
.RS
.IP
.I <field-name>
.B LINTERP
.I <input> <table>
.PP
where
.I input
is the input vector field for the table lookup, and
.I table
is the path to the lookup table file for the field.  If this path is relative,
it is assumed to be relative to the directory containing the format file
fragment defining this field.  The lookup table file is an ASCII text file with
two whitespace separated columns of
.I x
and
.I y
values.  Values are linearly interpolated between the points specified in the
lookup table.
.RE
.TP
.B MULTIPLY
The MULTIPLY vector field type is the product of two vector fields.  Syntax is:
.RS
.IP
.I <field-name>
.B MULTIPLY
.I <field1> <field2>
.PP
The derived field will be computed as:
.IP
field-name[n] = field1[n] * field2[n2]
.PP
with the index
.I n2
computed appropriately for the (potentially differing) sample rates of the
input fields.  The resultant field will have the same sample rate as
.IR field1 .
.RE
.TP
.B PHASE
The PHASE vector field type shifts an input vector field by the specified number
of samples.  Syntax is:
.RS
.IP
.I <field-name>
.B PHASE
.I <input> <shift>
.PP
which specifies
.I field-name
to be the input vector field,
.IR input ,
shifted by
.I shift
samples.  A positive
.I shift
indicates a shift forward in time.  Results of shifting past the beginning- or
end-of-file is implementation dependent.  The
.I shift
parameter may be either a literal number, or else the field code of a
.B CONST
field type containing its values.
.RE
.TP
.B POLYNOM
The POLYNOM vector field type specifies a polynomial function of a single input
vector field.  Synax is:
.RS
.IP
.I <field_name>
.B POLYNOM
.I <input> <a0> <a1>
.RI [ <a2> \~[ <a3> \~[ <a4> \~[ <a5> ]]]]
.PP
where
.I <input>
is the input field code, and the order of the computed polynomial is determined
by how many co-efficients are present in the specification.  The derived field
is computed as:
.IP
field-name[n] = a0 + a1 * input[n] + a2 * input[n]**2 + a3 * input[n]**3 +
a4 * input[n]**4 + a5 * input[n]**5
.PP
where
.I **
is the exponentiation operator, and the higher order terms are computed only
if the corresponding co-efficients
.RI a i
are specified.  The coefficients, if specified, may be either literal numbers,
or else the field code of a
.B CONST
field type containing the value.
.RE
.TP
.B RAW
The RAW vector field type specifies raw time streams on disk.  In this case, the
field name should correspond to the name of the file containing the time stream.
Syntax is:
.RS
.IP
.I <field-name>
.B RAW
.I <type> <sample-rate>
.PP
where
.I sample-rate
is the number of samples per dirfile frame for the time stream and
.I type
is a token specifying the native data format type:
.RS
.TP
.I UINT8
unsigned 8-bit integer
.TP
.I INT8
signed (two's complement) 8-bit integer
.TP
.I UINT16
unsigned 16-bit integer
.TP
.I INT16
signed (two's complement) 16-bit integer
.TP
.I UINT32
unsigned 32-bit integer
.TP
.I INT32
signed (two's complement) 32-bit integer
.TP
.I UINT64
unsigned 64-bit integer
.TP
.I INT64
signed (two's complement) 64-bit integer
.TP
.IR FLOAT32 \~or\~ FLOAT
IEEE-754 standard 32-bit single precision floating point number
.TP
.IR FLOAT64 \~or\~ DOUBLE
IEEE-754 standard 64-bit double precision floating point number
.TP
.I COMPLEX64
a 64-bit complex number consisting of two IEEE-754 standard 32-bit single
precision floating point numbers representing the real and imaginary parts of
the complex number.
.TP
.I COMPLEX128
a 128-bit complex number consisting of two IEEE-754 standard 64-bit double
precision floating point numbers representing the real and imaginary parts of
the complex number.
.RE

For more information on the storage of complex valued data, see dirfile(5).

For backwards compatibility, implementations should also recognise the following
single character type aliases in use prior to Standards Version 5:
.RS
.TP
.I c
UINT8
.TP
.I u
UINT16
.TP
.I s
INT16
.TP
.I U
UINT32
.TP
.IR i ,\~ S
INT32
.TP
.IR f
FLOAT32
.TP
.IR d
FLOAT64
.RE

Types
.IR INT8 ,\~ UINT64 ,\~ INT64 ,\~ COMPLEX64 ,
and
.I COMPLEX128
are not supported before Standards Version 5, so no single character type
aliases exist for these types.

The
.I sample-rate
parameter may be either a literal number, or else the name of a
.B CONST
field type containing its values.
.RE
.TP
.B SBIT
The SBIT vector field type extracts one or more bits out of an input vector
field as a signed number.  Syntax is:
.RS
.IP
.I <field-name>
.B SBIT
.I <input> <first-bit> [<bits>]
.PP
which specifies
.I field-name
to be the value of bits
.I first-bit
through
.IR first-bit + bits -1
of the input vector field
.IR input ,
when
.I input
is converted from its native type to a (endianness corrected) signed 64-bit
integer.  If
.I bits
is omitted, it is assumed to be 1.  Both
.IR first-bit " and " bits
may be either literal numbers, or else the field code of a
.B CONST
field type containing their values.  The
.B BIT
field type is an unsigned version of this field type.
.RE
.TP
.B STRING
The STRING scalar field type is a character string fully specified in the format
file metadata.  Syntax is:
.RS
.IP
.I <field-name>
.B STRING
.I <value>
.PP
where
.I value
is the string value of the field.  Note that
.I value
is a single token.  To include whitespace in the string, enclose
.I value
in quotation marks
.RB ( """" ),
or else escape the whitespace with the backslash character
.RB ( \e ).
.RE

.SS Field Parameters
All input vector field parameters should be
.I field codes
(see below).  Additionally, some of the numerical field parameters may be either
literal numbers or else the
.I field code
of a
.B CONST
field containing the value.  Parameters for which this is possible are indicated
above.  Since it is possible to create a field code which is identical to a
literal number, a parameter is assumed to be the field code of a 
.B CONST
field only if the entire token cannot be parsed as a literal number using the
rules outlined in
.BR strtod (3).
(So, for example, a
.B CONST
field whose field code consists solely of digits can never be used as a
parameter in a field specification line.)

A literal complex number is specified as two real (floating point) numbers
separated by a semicolon
.RB ( ; )
with no intervening whitespace.  So, for example, the tokens
.IP
1;0 0;1 4;0 0;5 9.313e2;74.1
.PP
represent, respectively, the real unit, the imaginary unit, the real number
four, the imaginary number
.RI 5 i ,
and the complex number
.RI "931.3 + 74.1" i .
Because the semicolon character cannot be used in field names, a complex valued
literal can never be mistaken for a field code.  This allows, among other
things, the composition of complex valued fields from purely real input fields.
For example, a complex valued field,
.IR z ,
may be created from a real valued field
.IR re ,
representing the real part of the complex number, and the real valued field
.IR im ,
representing the imaginary part of the complex number, with the following
.B LINCOM
specification:
.IP
.I z
.B LINCOM
.I re
1 0
.I im
0;1 0

.SS Field Codes
When specifying the input to a field, either as a
.B CONST
scalar parameter, or as an input vector field to a
.RB non- RAW
vector field,
.I field codes
are used.  A
.I field code
is one of:
.IP \(bu 4
a simple field name, indicating a vector or scalar field
.IP \(bu 4
a parent field name, followed by a forward slash, followed by a metafield name,
indicating a metafield.  See the description of the
.B META
directive above for further details. 
.IP \(bu 4
either of the above, followed by a period, followed by a
.IR "representation suffix" ,
but only if the field or metafield specified is not a
.B STRING
type field.
.PP
A 
.IR "representation suffix"
may be used used to extract a real number from a complex value.  The available
suffixes and their meanings are:
.TP
.B .a
This representation indicates the angle (in radians) between the positive real
axis and the value (ie. the complex argument).  The argument is in the range
[-pi, pi], and a branch cut exists along the negative real axis.  At the branch
cut, -pi is returned if the imaginary part is -0, and pi is returned if the
branch cut is +0.  If z=0, zero is returned.
.TP
.B .i
This representation indicates the projection of the value onto the imaginary
axis (ie. the imaginary part of the number).
.TP
.B .m
This representation indicates the modulus of the value (ie. its absolute
value).
.TP 
.B .r
This representation indicates the projection of the value onto the real axis
(ie.  the real part of the number).
.PP
If the specified field is purely real, the representations are calculated as
if the imaginary part was equal to +0.  For example, given a complex valued
vector,
.IR z ,
a vector containing the real part of
.IR z ,\~  re_z ,
could be produced with:
.IP
.I re_z
.B PHASE
.I z.r
0
.PP
and similarly for the complex field's imaginary part, argument, and absolute
value.  (Although it should be pointed out this simplistic an example isn't
strictly necessary, since
.I z.r
could be used wherever
.I re_z
would be.)

.SH STANDARDS VERSIONS

This document describes Version 7 of the Dirfile Standards.

Version 7 of the Standards (October 2009) added the
.B SBIT
and
.B POLYNOM
field types, and the directive-less method of specifying metafields.  It also
introduced the data types
.I COMPLEX128
and
.IR COMPLEX64 ,
along with the notion of
.IR representations .
Finally, it made the number of fields parameter for
.I LINCOM
optional.

Version 6 of the Standards (October 2008) added the
.BR /ENCODING ,\~ /META ,\~ /PROTECT ", and " /REFERENCE
directives, and the
.B CONST
and
.B STRING
field types.  It permitted whitespace in tokens and introduced the character
escape sequences. It allowed
.B CONST
fields to be used as parameters in field specification lines.  It also removed
.I FILEFRAM
as an alias for
.IR INDEX ,
and prohibited
.BR .
but allowed
.B #
and
.B \e
in field names.

Version 5 of the Standards (August 2008) added
.B /VERSION
and
.BR /ENDIAN ,
slash demarcation of reserved words, and removed the restriction on field
name length.  It introduced the data types
.IR INT8 ,\~ INT64 ,
and
.IR UINT64 ,
the new-style type specifiers, and increased the range of the
.B BIT
field type from 32 to 64 bits.  It also prohibited the characters
.B #&/;<>\e|
in field names.

Version 4 of the Standards (October 2006) added the
.B PHASE
field type.

Version 3 of the Standards (January 2006) added
.B INCLUDE 
and increased the allowed length of a field name from 16 to 50 characters.

Version 2 of the Standards (September 2005) added the
.B MULTIPLY
field type.

Version 1 of the Standards (November 2004) added
.B FRAMEOFFSET
and the optional fourth argument to the
.B BIT
field type.

Version 0 of the Standards (before March 2003) refers to the dirfile standards
supported by the
.BR getdata (3)
library originally introduced into the
.BR kst (1)
sources, which contained support for all other features covered by this
document.

.SH AUTHORS

The dirfile specification was developed by C. B. Netterfield
.nh
<netterfield@astro.utoronto.ca>.
.hy 1

Since Standards Version 3, the dirfile specification has been maintained by
D. V. Wiebe
.nh
<getdata@ketiltrout.net>.
.hy 1

.SH SEE ALSO
.BR dirfile (5),
.BR dirfile\-encoding (5)
