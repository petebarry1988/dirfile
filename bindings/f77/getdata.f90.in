! (C) 2008 D. V. Wiebe
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! This file is part of the GetData project.
!
! This program is free software; you can redistribute it and/or modify it
! under the terms of the GNU General Public License as published by the
! Free Software Foundation; either version 2 of the License, or (at your
! option) any later version.
!
! GetData is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
! FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
! for more details.
!
! You should have received a copy of the GNU General Public License along
! with GetData; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
!
! -*- F95 -*-

module getdata
implicit none

@PARAMETERS95@

integer, parameter :: GD_FIELD_LEN=@GD_MAX_LINE_LENGTH@

type gd_entry
  integer :: field_type, n_fields, spf, data_type, bitnum, numbits, shift
  integer :: fragment_index
  character (len=GD_FIELD_LEN), dimension(3) :: field
  real*8, dimension(3) :: m, b
end type

contains
function fdirfile_open (dirfilename, flags)
  integer :: fdirfile_open
  character (len=*), intent (in) :: dirfilename
  integer, intent (in) :: flags

  ! call f77 library
  call gdopen(fdirfile_open, TRIM(dirfilename), LEN_TRIM(dirfilename), flags)
end function

function fdirfile_cbopen (dirfilename, flags, sehandler)
  integer :: fdirfile_cbopen
  character (len=*), intent (in) :: dirfilename
  integer, intent (in) :: flags
  interface
    subroutine sehandler(act, dirfile_unit, suberror, line)
      integer, intent (out) :: act
      integer, intent (in) :: dirfile_unit, suberror
      character (len=@GD_MAX_LINE_LENGTH@), intent (inout) :: line
    end subroutine
  end interface

  ! call f77 library
  call gdcopn(fdirfile_cbopen, TRIM(dirfilename), LEN_TRIM(dirfilename), &
  flags, sehandler)
end function

subroutine fdirfile_discard (dirfile)
  integer, intent(in) :: dirfile

  ! call f77 library
  call gddscd(dirfile)
end subroutine

subroutine fdirfile_close (dirfile)
  integer, intent(in) :: dirfile

  ! call f77 library
  call gdclos(dirfile)
end subroutine

subroutine fdirfile_flush (dirfile, field_code)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  ! call f77 library -- this will take care of figuring out whether
  !                     field_code is empty or not
  call gdflsh(dirfile, TRIM(field_code), LEN_TRIM(field_code))
end subroutine

! getdata with return_type=GD_NULL
function fgetdata_n (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples)
  integer :: fgetdata_n
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples

  ! call f77 library
  call gdgetd(fgetdata_n, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_NULL, 0)
end function

! getdata with return_type=GD_INT8
function fgetdata_i1 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_i1
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*1, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_i1, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT8, data_out)
end function

! getdata with return_type=GD_INT16
function fgetdata_i2 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_i2
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*2, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_i2, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT16, data_out)
end function

! getdata with return_type=GD_INT32
function fgetdata_i4 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_i4
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*4, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_i4, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT32, data_out)
end function

! getdata with return_type=GD_INT64
function fgetdata_i8 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_i8
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*8, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_i8, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT64, data_out)
end function

! getdata with return_type=GD_FLOAT32
function fgetdata_r4 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_r4
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  real*4, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_r4, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_FLOAT32, data_out)
end function

! getdata with return_type=GD_FLOAT64
function fgetdata_r8 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_out)
  integer :: fgetdata_r8
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  real*8, dimension(:), intent(out) :: data_out

  ! call f77 library
  call gdgetd(fgetdata_r8, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_FLOAT64, data_out)
end function

!get_constant with return_type=GD_NULL
function fget_constant_n (dirfile, field_code)
  integer :: fget_constant_n
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  
  ! call f77 library
  call gdgtco(fget_constant_n, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_NULL, 0)
end function

!get_constant with return_type=GD_INT8
function fget_constant_i1 (dirfile, field_code, data_out)
  integer :: fget_constant_i1
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*1, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_i1, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT8, data_out)
end function

!get_constant with return_type=GD_INT16
function fget_constant_i2 (dirfile, field_code, data_out)
  integer :: fget_constant_i2
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*2, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_i2, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT16, data_out)
end function

!get_constant with return_type=GD_INT32
function fget_constant_i4 (dirfile, field_code, data_out)
  integer :: fget_constant_i4
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*4, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_i4, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT32, data_out)
end function

!get_constant with return_type=GD_INT64
function fget_constant_i8 (dirfile, field_code, data_out)
  integer :: fget_constant_i8
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*8, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_i8, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT64, data_out)
end function

!get_constant with return_type=GD_FLOAT32
function fget_constant_r4 (dirfile, field_code, data_out)
  integer :: fget_constant_r4
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  real*4, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_r4, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_FLOAT32, data_out)
end function

!get_constant with return_type=GD_FLOAT64
function fget_constant_r8 (dirfile, field_code, data_out)
  integer :: fget_constant_r8
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  real*8, intent(out)  :: data_out
  
  ! call f77 library
  call gdgtco(fget_constant_r8, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_FLOAT64, data_out)
end function

function fget_string (dirfile, field_code, length, data_out)
  integer :: fget_string
  integer, intent(in) :: dirfile, length
  character (len=*), intent(in) :: field_code
  character (len=*), intent(out) :: data_out

  ! call f77 library
  call gdgtst(fget_string, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  length, data_out)
end function

function fget_nfields (dirfile)
  integer :: fget_nfields
  integer, intent(in) :: dirfile

  ! call f77 library
  call gdnfld(fget_nfields, dirfile)
end function

function fget_nfields_by_type (dirfile, entype)
  integer :: fget_nfields_by_type
  integer, intent(in) :: dirfile, entype

  call gdnfdt(fget_nfields_by_type, dirfile, entype)
end function

function fget_nvectors (dirfile)
  integer :: fget_nvectors
  integer, intent(in) :: dirfile

  call gdnvec(fget_nvectors, dirfile)
end function

function fget_nmfields (dirfile, parent)
  integer :: fget_nmfields
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: parent

  ! call f77 library
  call gdnfld(fget_nmfields, dirfile, TRIM(parent), LEN_TRIM(parent))
end function

function fget_nmfields_by_type (dirfile, parent, entype)
  integer :: fget_nmfields_by_type
  integer, intent(in) :: dirfile, entype
  character (len=*), intent(in) :: parent

  call gdnmft(fget_nmfields_by_type, dirfile, TRIM(parent), LEN_TRIM(parent), &
  entype)
end function

function fget_nmvectors (dirfile, parent)
  integer :: fget_nmvectors
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: parent

  call gdnmve(fget_nmvectors, dirfile, TRIM(parent), LEN_TRIM(parent))
end function

function fget_field_name_max (dirfile)
  integer :: fget_field_name_max
  integer, intent(in) :: dirfile

  ! call f77 library
  call gdfdnx(fget_field_name_max, dirfile)
end function

function fget_mfield_name_max (dirfile, parent)
  integer :: fget_mfield_name_max
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: parent

  ! call f77 library
  call gdmfnx(fget_mfield_name_max, dirfile, TRIM(parent), LEN_TRIM(parent))
end function

subroutine fget_field_list (field_list, dirfile, field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i

  ! make sure the field list is large enough
  max_len = fget_field_name_max(dirfile)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nfields(dirfile)
    do i=1,nfields
      ! call f77 library
      call gdfldn(field_list(i), field_len, dirfile, i)
    end do
  end if
end subroutine

subroutine fget_field_list_by_type (field_list, dirfile, entype, field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile, entype
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i

  ! make sure the field list is large enough
  max_len = fget_field_name_max(dirfile)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nfields_by_type(dirfile, entype)
    do i=1,nfields
      ! call f77 library
      call gdfdnt(field_list(i), field_len, dirfile, entype, i)
    end do
  end if
end subroutine

subroutine fget_vector_list (field_list, dirfile, field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i

  ! make sure the field list is large enough
  max_len = fget_field_name_max(dirfile)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nvectors(dirfile)
    do i=1,nfields
      ! call f77 library
      call gdvecn(field_list(i), field_len, dirfile, i)
    end do
  end if
end subroutine

subroutine fget_mfield_list (field_list, dirfile, parent, field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i
  character (len=*), intent(in) :: parent

  ! make sure the field list is large enough
  max_len = fget_mfield_name_max(dirfile, parent)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nmfields(dirfile, parent)
    do i=1,nfields
      ! call f77 library
      call gdmfdn(field_list(i), field_len, dirfile, TRIM(parent), &
      LEN_TRIM(parent), i)
    end do
  end if
end subroutine

subroutine fget_mfield_list_by_type (field_list, dirfile, parent, entype, &
field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile, entype
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i
  character (len=*), intent(in) :: parent

  ! make sure the field list is large enough
  max_len = fget_mfield_name_max(dirfile, parent)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nmfields_by_type(dirfile, parent, entype)
    do i=1,nfields
      ! call f77 library
      call gdmfdt(field_list(i), field_len, dirfile, TRIM(parent), &
      LEN_TRIM(parent), entype, i)
    end do
  end if
end subroutine

subroutine fget_mvector_list (field_list, dirfile, parent, field_len)
  character(len=*), dimension(:), intent(out) :: field_list
  integer, intent(in) :: dirfile
  integer, intent(inout) :: field_len
  integer :: max_len, nfields, i
  character (len=*), intent(in) :: parent

  ! make sure the field list is large enough
  max_len = fget_mfield_name_max(dirfile, parent)

  if (field_len .lt. max_len) then
    field_len = max_len
  else
    nfields = fget_nmvectors(dirfile, parent)
    do i=1,nfields
      ! call f77 library
      call gdmven(field_list(i), field_len, TRIM(parent), LEN_TRIM(parent), &
      dirfile, i)
    end do
  end if
end subroutine

function fget_nframes (dirfile)
  integer :: fget_nframes
  integer, intent(in) :: dirfile

  ! call f77 library
  call gdnfrm(fget_nframes, dirfile)
end function

function fget_spf (dirfile, field_code)
  integer :: fget_spf
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  ! call f77 library
  call gdgspf(fget_spf, dirfile, TRIM(field_code), LEN_TRIM(field_code))
end function

! putdata with data_type=GD_INT8
function fputdata_i1 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_i1
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*1, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_i1, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT8, data_in)
end function

! putdata with data_type=GD_INT16
function fputdata_i2 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_i2
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*2, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_i2, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT16, data_in)
end function

! putdata with data_type=GD_INT32
function fputdata_i4 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_i4
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*4, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_i4, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT32, data_in)
end function

! putdata with data_type=GD_INT64
function fputdata_i8 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_i8
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  integer*8, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_i8, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_INT64, data_in)
end function

! putdata with data_type=GD_FLOAT32
function fputdata_r4 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_r4
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  real*4, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_r4, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_FLOAT32, data_in)
end function

! putdata with data_type=GD_FLOAT64
function fputdata_r8 (dirfile, field_code, first_frame, first_sample, &
  num_frames, num_samples, data_in)
  integer :: fputdata_r8
  integer, intent(in) :: dirfile, first_frame, first_sample, num_frames
  character (len=*), intent(in) :: field_code
  integer, intent(in) :: num_samples
  real*8, dimension(:), intent(in) :: data_in

  ! call f77 library
  call gdputd(fputdata_r8, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  first_frame, first_sample, num_frames, num_samples, GD_FLOAT64, data_in)
end function

! put_constant with data_type=GD_INT8
function fput_constant_i1 (dirfile, field_code, data_in)
  integer :: fput_constant_i1
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*1, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_i1, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT8, data_in)
end function

! put_constant with data_type=GD_INT16
function fput_constant_i2 (dirfile, field_code, data_in)
  integer :: fput_constant_i2
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*2, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_i2, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT16, data_in)
end function

! put_constant with data_type=GD_INT32
function fput_constant_i4 (dirfile, field_code, data_in)
  integer :: fput_constant_i4
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*4, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_i4, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT32, data_in)
end function

! put_constant with data_type=GD_INT64
function fput_constant_i8 (dirfile, field_code, data_in)
  integer :: fput_constant_i8
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  integer*8, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_i8, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_INT64, data_in)
end function

! put_constant with data_type=GD_FLOAT32
function fput_constant_r4 (dirfile, field_code, data_in)
  integer :: fput_constant_r4
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  real*4, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_r4, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_FLOAT32, data_in)
end function

! put_constant with data_type=GD_FLOAT64
function fput_constant_r8 (dirfile, field_code, data_in)
  integer :: fput_constant_r8
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  real*8, intent(in) :: data_in

  ! call f77 library
  call gdptco(fput_constant_r8, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code), GD_FLOAT64, data_in)
end function

function fput_string (dirfile, field_code, data_in)
  integer :: fput_string
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code, data_in

  call gdptst(fput_string, dirfile, TRIM(field_code), LEN_TRIM(field_code), &
  LEN_TRIM(data_in), TRIM(data_in))
end function

function fget_error (dirfile)
  integer :: fget_error
  integer, intent(in) :: dirfile

  ! call f77 library
  call gderor(fget_error, dirfile)
end function

subroutine fget_error_string (dirfile, buffer, len)
  integer, intent(in) :: dirfile, len
  character (len=*), intent(out) :: buffer

  ! call f77 library
  call gdestr(dirfile, buffer, len)
end subroutine

function fget_entry (dirfile, field_code, ent)
  integer :: fget_entry
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  type(gd_entry), intent(out) :: ent

  ! the call may modify the lengths, so don't use parameters
  integer :: len1 = GD_FIELD_LEN
  integer :: len2 = GD_FIELD_LEN
  integer :: len3 = GD_FIELD_LEN

  ! get field type from f77 library
  call gdenty(fget_entry, dirfile, TRIM(field_code), LEN_TRIM(field_code))

  if (fget_entry .EQ. GD_RAW_ENTRY) then
    ! raw
    call gdgerw(ent%spf, ent%data_type, ent%fragment_index, dirfile, &
    TRIM(field_code), LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_LINCOM_ENTRY) then
    ! lincom
    call gdgelc(ent%n_fields, ent%field(1), len1, ent%m(1), ent%b(1), &
    ent%field(2), len2, ent%m(2), ent%b(2), ent%field(3), len3, ent%m(3), &
    ent%b(3), ent%fragment_index, dirfile, TRIM(field_code), &
    LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_LINTERP_ENTRY) then
    ! linterp
    call gdgelt(ent%field(1), len1, ent%field(2), len2, ent%fragment_index, &
    dirfile, TRIM(field_code), LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_BIT_ENTRY) then
    ! bit
    call gdgebt(ent%field(1), len1, ent%bitnum, ent%numbits, &
    ent%fragment_index, dirfile, TRIM(field_code), LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_MULTIPLY_ENTRY) then
    ! multiply
    call gdgemt(ent%field(1), len1, ent%field(2), len2, ent%fragment_index, &
    dirfile, TRIM(field_code), LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_PHASE_ENTRY) then
    !phase
    call gdgemt(ent%field(1), len1, ent%shift, ent%fragment_index, dirfile, &
    TRIM(field_code), LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_CONST_ENTRY) then
    !const
    call gdgeco(ent%data_type, ent%fragment_index, dirfile, TRIM(field_code), &
    LEN_TRIM(field_code))
  else if (fget_entry .EQ. GD_STRING_ENTRY) then
    !string
    call gdfrgi(ent%fragment_index, dirfile, TRIM(field_code), &
    LEN_TRIM(field_code))
  else
    ! on the off chance we got a type we weren't prepared to deal with
    fget_entry = GD_NO_ENTRY
  end if
  ent%field_type = fget_entry
end function

function fget_entry_type (dirfile, field_code)
  integer :: fget_entry_type
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  call gdenty(fget_entry_type, dirfile, TRIM(field_code), LEN_TRIM(field_code))
end function

function fget_fragment_index (dirfile, field_code)
  integer :: fget_fragment_index
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  call gdfrgi(fget_fragment_index, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code))
end function

subroutine fdirfile_add (dirfile, field_code, ent)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code
  type(gd_entry), intent(in) :: ent
  integer*4 :: zero = 0
  character (len=1) :: nil = ""

  if (ent%field_type .EQ. GD_RAW_ENTRY) then
    call gdadrw(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    ent%data_type, ent%spf, ent%fragment_index)
  else if (ent%field_type .EQ. GD_LINCOM_ENTRY) then
    call gdadlc(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    ent%n_fields, TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%m(1), &
    ent%b(1), TRIM(ent%field(2)), LEN_TRIM(ent%field(2)), ent%m(2), ent%b(2), &
    TRIM(ent%field(3)), LEN_TRIM(ent%field(3)), ent%m(3), ent%b(3), &
    ent%fragment_index)
  else if (ent%field_type .EQ. GD_LINTERP_ENTRY) then
    call gdadlt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), TRIM(ent%field(2)), &
    LEN_TRIM(ent%field(2)), ent%fragment_index)
  else if (ent%field_type .EQ. GD_BIT_ENTRY) then
    call gdadbt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%bitnum, ent%numbits, &
    ent%fragment_index)
  else if (ent%field_type .EQ. GD_MULTIPLY_ENTRY) then
    call gdadmt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), TRIM(ent%field(2)), &
    LEN_TRIM(ent%field(2)), ent%fragment_index)
  else if (ent%field_type .EQ. GD_PHASE_ENTRY) then
    call gdadph(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%shift, ent%fragment_index)
  else if (ent%field_type .EQ. GD_CONST_ENTRY) then
    call gdadco(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    ent%data_type, GD_INT32, zero, ent%fragment_index)
  else if (ent%field_type .EQ. GD_STRING_ENTRY) then
    call gdadst(dirfile, TRIM(field_code), LEN_TRIM(field_code), nil, zero, &
    ent%fragment_index);
  end if
end subroutine

subroutine fdirfile_add_bit (dirfile, field_name, in_field, bitnum, numbits, &
  fragment_index)
  integer, intent(in) :: dirfile, bitnum, numbits, fragment_index
  character (len=*), intent(in) :: field_name, in_field

  call gdadbt(dirfile, TRIM(field_name), LEN_TRIM(field_name), TRIM(in_field), &
  LEN_TRIM(in_field), bitnum, numbits, fragment_index)
end subroutine

subroutine fdirfile_add_const (dirfile, field_name, const_type, fragment_index)
  integer, intent(in) :: dirfile, const_type, fragment_index
  character (len=*), intent(in) :: field_name
  integer*4 :: zero = 0

  call gdadco(dirfile, TRIM(field_name), LEN_TRIM(field_name), const_type, &
  GD_INT32, zero, fragment_index)
end subroutine

subroutine fdirfile_add_lincom (dirfile, field_name, n_fields, in_field1, m1, &
  b1, in_field2, m2, b2, in_field3, m3, b3, fragment_index)
  integer, intent(in) :: dirfile, n_fields, fragment_index
  character (len=*), intent(in) :: field_name, in_field1, in_field2, in_field3
  real*8, intent(in) :: m1, b1, m2, b2, m3, b3

  call gdadlc(dirfile, TRIM(field_name), LEN_TRIM(field_name), n_fields, &
  TRIM(in_field1), LEN_TRIM(in_field1), m1, b1, TRIM(in_field2), &
  LEN_TRIM(in_field2), m2, b2, TRIM(in_field3), LEN_TRIM(in_field3), m3, b3, &
  fragment_index)
end subroutine

subroutine fdirfile_add_linterp (dirfile, field_name, in_field, table, &
  fragment_index)
  integer, intent(in) :: dirfile, fragment_index
  character (len=*), intent(in) :: field_name, in_field, table

  call gdadlt(dirfile, TRIM(field_name), LEN_TRIM(field_name), TRIM(in_field), &
  LEN_TRIM(in_field), TRIM(table), LEN_TRIM(table), fragment_index)
end subroutine

subroutine fdrifile_add_multiply (dirfile, field_name, in_field1, in_field2, &
  fragment_index)
  integer, intent(in) :: dirfile, fragment_index
  character (len=*), intent(in) :: field_name, in_field1, in_field2

  call gdadmt(dirfile, TRIM(field_name), LEN_TRIM(field_name), &
  TRIM(in_field1), LEN_TRIM(in_field1), TRIM(in_field2), LEN_TRIM(in_field2), &
  fragment_index)
end subroutine

subroutine fdrifile_add_phase (dirfile, field_name, in_field, phase, &
  fragment_index)
  integer, intent(in) :: dirfile, phase, fragment_index
  character (len=*), intent(in) :: field_name, in_field

  call gdadph(dirfile, TRIM(field_name), LEN_TRIM(field_name), &
  TRIM(in_field), LEN_TRIM(in_field), phase, fragment_index)
end subroutine

subroutine fdirfile_add_raw (dirfile, field_code, data_type, spf, &
  fragment_index)
  integer, intent(in) :: dirfile, data_type, spf, fragment_index
  character (len=*), intent(in) :: field_code

  call gdadrw(dirfile, TRIM(field_code), LEN_TRIM(field_code), data_type, spf, &
  fragment_index)
end subroutine

subroutine fdirfile_add_string (dirfile, field_code, fragment_index)
  integer, intent(in) :: dirfile, fragment_index
  character (len=*), intent(in) :: field_code
  
  character (len=1) :: nil = ""

  call gdadst(dirfile, TRIM(field_code), LEN_TRIM(field_code), nil, 0, &
  fragment_index)
end subroutine

subroutine fdirfile_madd (dirfile, parent, field_code, ent)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code, parent
  type(gd_entry), intent(in) :: ent
  integer*4 :: zero = 0
  character (len=1) :: nil = ""

  if (ent%field_type .EQ. GD_LINCOM_ENTRY) then
    call gdmdlc(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), ent%n_fields, TRIM(ent%field(1)), &
    LEN_TRIM(ent%field(1)), ent%m(1), ent%b(1), TRIM(ent%field(2)), &
    LEN_TRIM(ent%field(2)), ent%m(2), ent%b(2), TRIM(ent%field(3)), &
    LEN_TRIM(ent%field(3)), ent%m(3), ent%b(3))
  else if (ent%field_type .EQ. GD_LINTERP_ENTRY) then
    call gdmdlt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), &
    TRIM(ent%field(2)), LEN_TRIM(ent%field(2)))
  else if (ent%field_type .EQ. GD_BIT_ENTRY) then
    call gdmdbt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), &
    ent%bitnum, ent%numbits)
  else if (ent%field_type .EQ. GD_MULTIPLY_ENTRY) then
    call gdmdmt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), &
    TRIM(ent%field(2)), LEN_TRIM(ent%field(2)))
  else if (ent%field_type .EQ. GD_PHASE_ENTRY) then
    call gdmdph(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%shift)
  else if (ent%field_type .EQ. GD_CONST_ENTRY) then
    call gdmdco(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), ent%data_type, GD_INT32, zero)
  else if (ent%field_type .EQ. GD_STRING_ENTRY) then
    call gdmdst(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
    LEN_TRIM(field_code), nil, zero)
  end if
end subroutine

subroutine fdirfile_madd_bit (dirfile, parent, field_name, in_field, bitnum, &
  numbits)
  integer, intent(in) :: dirfile, bitnum, numbits
  character (len=*), intent(in) :: field_name, in_field, parent

  call gdmdbt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), TRIM(in_field), LEN_TRIM(in_field), bitnum, numbits)
end subroutine

subroutine fdirfile_madd_const (dirfile, parent, field_name, const_type)
  integer, intent(in) :: dirfile, const_type
  character (len=*), intent(in) :: field_name, parent
  integer*4 :: zero = 0

  call gdmdco(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), const_type, GD_INT32, zero)
end subroutine

subroutine fdirfile_madd_lincom (dirfile, parent, field_name, n_fields, &
  in_field1, m1, b1, in_field2, m2, b2, in_field3, m3, b3)
  integer, intent(in) :: dirfile, n_fields
  character (len=*), intent(in) :: field_name, in_field1, in_field2, in_field3
  character (len=*), intent(in) :: parent
  real*8, intent(in) :: m1, b1, m2, b2, m3, b3

  call gdmdlc(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), n_fields, TRIM(in_field1), LEN_TRIM(in_field1), m1, &
  b1, TRIM(in_field2), LEN_TRIM(in_field2), m2, b2, TRIM(in_field3), &
  LEN_TRIM(in_field3), m3, b3)
end subroutine

subroutine fdirfile_madd_linterp (dirfile, parent, field_name, in_field, table)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_name, in_field, table, parent

  call gdmdlt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), TRIM(in_field), LEN_TRIM(in_field), TRIM(table), &
  LEN_TRIM(table))
end subroutine

subroutine fdrifile_madd_multiply (dirfile, parent, field_name, in_field1, &
  in_field2)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_name, in_field1, in_field2, parent

  call gdmdmt(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), TRIM(in_field1), LEN_TRIM(in_field1), TRIM(in_field2), &
  LEN_TRIM(in_field2))
end subroutine

subroutine fdrifile_madd_phase (dirfile, parent, field_name, in_field, phase)
  integer, intent(in) :: dirfile, phase
  character (len=*), intent(in) :: field_name, in_field, parent

  call gdmdph(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_name), &
  LEN_TRIM(field_name), TRIM(in_field), LEN_TRIM(in_field), phase)
end subroutine

subroutine fdirfile_madd_string (dirfile, parent, field_code)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code, parent
  
  character (len=1) :: nil = ""

  call gdmdst(dirfile, TRIM(parent), LEN_TRIM(parent), TRIM(field_code), &
  LEN_TRIM(field_code), nil, 0)
end subroutine

subroutine fdirfile_add_spec (dirfile, spec, fragment_index)
  integer, intent(in) :: dirfile, fragment_index
  character (len=*), intent(in) :: spec

  call gdadsp(dirfile, TRIM(spec), LEN_TRIM(spec), fragment_index)
end subroutine

subroutine fdirfile_madd_spec (dirfile, spec, parent)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: parent, spec

  call gdmdsp(dirfile, TRIM(spec), LEN_TRIM(spec), TRIM(parent), &
  LEN_TRIM(parent))
end subroutine

function fget_fragmentname (dirfile, ind)
  character (len=GD_FIELD_LEN) :: fget_fragmentname
  integer, intent(in) :: dirfile, ind
  integer :: l = GD_FIELD_LEN

  call gdfrgn(fget_fragmentname, l, dirfile, ind)
end function

function fget_nfragments (dirfile)
  integer :: fget_nfragments
  integer, intent(in) :: dirfile

  call gdnfrg(fget_nfragments, dirfile)
end function

subroutine fdirfile_metaflush (dirfile)
  integer, intent(in) :: dirfile

  call gdmfls(dirfile)
end subroutine

subroutine fdirfile_include (dirfile, fragmentname, fragment_index, flags)
  integer, intent(in) :: dirfile, fragment_index, flags
  character (len=*), intent(in) :: fragmentname

  call gdincl(dirfile, TRIM(fragmentname), LEN_TRIM(fragmentname), &
  fragment_index, flags)
end subroutine

function fget_reference (dirfile)
  character (len=GD_FIELD_LEN) :: fget_reference
  integer, intent(in) :: dirfile

  integer :: l = GD_FIELD_LEN

  call gdgref(fget_reference, l, dirfile)
end function

function fdirfile_reference (dirfile, field_code)
  character (len=GD_FIELD_LEN) :: fdirfile_reference
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  integer :: l = GD_FIELD_LEN

  call gdrefe(fdirfile_reference, l, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code))
end function 

subroutine fdirfile_parser_callback (dirfile, sehandler)
  integer, intent(in) :: dirfile
  interface
    subroutine sehandler(act, dirfile_unit, suberror, line)
      integer, intent (out) :: act
      integer, intent (in) :: dirfile_unit, suberror
      character (len=@GD_MAX_LINE_LENGTH@), intent (inout) :: line
    end subroutine
  end interface

  call gdclbk(dirfile, sehandler)
end subroutine

function fget_encoding (dirfile, fragment)
  integer :: fget_encoding
  integer, intent(in) :: dirfile, fragment

  call gdgenc(fget_encoding, dirfile, fragment)
end function

subroutine fdirfile_alter_encoding (dirfile, encoding, fragment, recode)
  integer, intent(in) :: dirfile, encoding, fragment, recode

  call gdaenc(dirfile, encoding, fragment, recode)
end subroutine

function fget_endianness (dirfile, fragment)
  integer :: fget_endianness
  integer, intent(in) :: dirfile, fragment

  call gdgend(fget_endianness, dirfile, fragment)
end function

subroutine fdirfile_alter_endianness (dirfile, endianness, fragment, recode)
  integer, intent(in) :: dirfile, endianness, fragment, recode

  call gdaend(dirfile, endianness, fragment, recode)
end subroutine

function fget_frameoffset (dirfile, fragment)
  integer :: fget_frameoffset
  integer, intent(in) :: dirfile, fragment

  call gdgfof(fget_frameoffset, dirfile, fragment)
end function

subroutine fdirfile_alter_frameoffset (dirfile, frameoffset, fragment, recode)
  integer, intent(in) :: dirfile, frameoffset, fragment, recode

  call gdafof(dirfile, frameoffset, fragment, recode)
end subroutine

function fget_protection (dirfile, fragment)
  integer :: fget_protection
  integer, intent(in) :: dirfile, fragment

  call gdgprt(fget_protection, dirfile, fragment)
end function

subroutine fdirfile_protect (dirfile, protection_level, fragment)
  integer, intent(in) :: dirfile, protection_level, fragment

  call gdprot(dirfile, protection_level, fragment)
end subroutine

function fget_parent_fragment (dirfile, fragment)
  integer :: fget_parent_fragment
  integer, intent(in) :: dirfile, fragment

  call gdpfrg(fget_parent_fragment, dirfile, fragment)
end function

subroutine fdirfile_uninclude (dirfile, fragment, del)
  integer, intent(in) :: dirfile, fragment, del

  call gduinc(dirfile, fragment, del)
end subroutine

function fget_raw_filename (dirfile, field_code)
  character (len=GD_MAX_LINE_LENGTH) :: fget_raw_filename
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_code

  integer :: l = GD_MAX_LINE_LENGTH

  call gdrwfn (fget_raw_filename, l, dirfile, TRIM(field_code), &
  LEN_TRIM(field_code))
end function

subroutine fdirfile_move (dirfile, field_code, new_fragment, move_data)
  integer, intent(in) :: dirfile, new_fragment, move_data
  character (len=*), intent(in) :: field_code

  call gdmove (dirfile, TRIM(field_code), LEN_TRIM(field_code), new_fragment, &
  move_data)
end subroutine

subroutine fdirfile_alter_entry (dirfile, field_code, ent, recode)
  integer, intent(in) :: dirfile, recode
  character (len=*), intent(in) :: field_code
  type(gd_entry), intent(in) :: ent

  if (ent%field_type .EQ. GD_RAW_ENTRY) then
    call gdalrw(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    ent%data_type, ent%spf, recode)
  else if (ent%field_type .EQ. GD_LINCOM_ENTRY) then
    call gdallc(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    ent%n_fields, TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%m(1), &
    ent%b(1), TRIM(ent%field(2)), LEN_TRIM(ent%field(2)), ent%m(2), ent%b(2), &
    TRIM(ent%field(3)), LEN_TRIM(ent%field(3)), ent%m(3), ent%b(3))
  else if (ent%field_type .EQ. GD_LINTERP_ENTRY) then
    call gdallt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), TRIM(ent%field(2)), &
    LEN_TRIM(ent%field(2)), recode)
  else if (ent%field_type .EQ. GD_BIT_ENTRY) then
    call gdalbt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%bitnum, ent%numbits)
  else if (ent%field_type .EQ. GD_MULTIPLY_ENTRY) then
    call gdalmt(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), TRIM(ent%field(2)), &
    LEN_TRIM(ent%field(2)))
  else if (ent%field_type .EQ. GD_PHASE_ENTRY) then
    call gdalph(dirfile, TRIM(field_code), LEN_TRIM(field_code), &
    TRIM(ent%field(1)), LEN_TRIM(ent%field(1)), ent%shift)
  else if (ent%field_type .EQ. GD_CONST_ENTRY) then
    call gdalco(dirfile, TRIM(field_code), LEN_TRIM(field_code), ent%data_type)
  end if
end subroutine

subroutine fdirfile_alter_bit (dirfile, field_name, in_field, bitnum, numbits)
  integer, intent(in) :: dirfile, bitnum, numbits
  character (len=*), intent(in) :: field_name, in_field

  call gdalbt(dirfile, TRIM(field_name), LEN_TRIM(field_name), TRIM(in_field), &
  LEN_TRIM(in_field), bitnum, numbits)
end subroutine

subroutine fdirfile_alter_const (dirfile, field_name, const_type)
  integer, intent(in) :: dirfile, const_type
  character (len=*), intent(in) :: field_name

  call gdalco(dirfile, TRIM(field_name), LEN_TRIM(field_name), const_type)
end subroutine

subroutine fdirfile_alter_lincom (dirfile, field_name, n_fields, in_field1, &
  m1, b1, in_field2, m2, b2, in_field3, m3, b3)
  integer, intent(in) :: dirfile, n_fields
  character (len=*), intent(in) :: field_name, in_field1, in_field2, in_field3
  real*8, intent(in) :: m1, b1, m2, b2, m3, b3

  call gdallc(dirfile, TRIM(field_name), LEN_TRIM(field_name), n_fields, &
  TRIM(in_field1), LEN_TRIM(in_field1), m1, b1, TRIM(in_field2), &
  LEN_TRIM(in_field2), m2, b2, TRIM(in_field3), LEN_TRIM(in_field3), m3, b3)
end subroutine

subroutine fdirfile_alter_linterp (dirfile, field_name, in_field, table, move)
  integer, intent(in) :: dirfile, move
  character (len=*), intent(in) :: field_name, in_field, table

  call gdallt(dirfile, TRIM(field_name), LEN_TRIM(field_name), TRIM(in_field), &
  LEN_TRIM(in_field), TRIM(table), LEN_TRIM(table), move)
end subroutine

subroutine fdrifile_alter_multiply (dirfile, field_name, in_field1, in_field2)
  integer, intent(in) :: dirfile
  character (len=*), intent(in) :: field_name, in_field1, in_field2

  call gdalmt(dirfile, TRIM(field_name), LEN_TRIM(field_name), &
  TRIM(in_field1), LEN_TRIM(in_field1), TRIM(in_field2), LEN_TRIM(in_field2))
end subroutine

subroutine fdrifile_alter_phase (dirfile, field_name, in_field, phase)
  integer, intent(in) :: dirfile, phase
  character (len=*), intent(in) :: field_name, in_field

  call gdalph(dirfile, TRIM(field_name), LEN_TRIM(field_name), &
  TRIM(in_field), LEN_TRIM(in_field), phase)
end subroutine

subroutine fdirfile_alter_raw (dirfile, field_code, data_type, spf, move)
  integer, intent(in) :: dirfile, data_type, spf, move
  character (len=*), intent(in) :: field_code

  call gdalrw(dirfile, TRIM(field_code), LEN_TRIM(field_code), data_type, spf, &
  move)
end subroutine

subroutine fdirfile_alter_spec (dirfile, spec, recode)
  integer, intent(in) :: dirfile, recode
  character (len=*), intent(in) :: spec

  call gdalsp(dirfile, TRIM(spec), LEN_TRIM(spec), recode)
end subroutine

subroutine fdirfile_malter_spec (dirfile, spec, parent, recode)
  integer, intent(in) :: dirfile, recode
  character (len=*), intent(in) :: parent, spec

  call gdmlsp(dirfile, TRIM(spec), LEN_TRIM(spec), TRIM(parent), &
  LEN_TRIM(parent), recode)
end subroutine

subroutine fdirfile_rename (dirfile, field_code, new_name, move_data)
  integer, intent(in) :: dirfile, move_data
  character (len=*), intent(in) :: field_code, new_name

  call gdrenm(dirfile, TRIM(field_code), LEN_TRIM(field_code), TRIM(new_name), &
  LEN_TRIM(new_name), move_data)
end subroutine

subroutine fdirfile_delete (dirfile, field_code, flags)
  integer, intent(in) :: dirfile, flags
  character (len=*), intent(in) :: field_code

  call gddele(dirfile, TRIM(field_code), LEN_TRIM(field_code), flags)
end subroutine

end module
