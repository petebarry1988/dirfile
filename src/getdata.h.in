/* (C) 2002-2005 C. Barth Netterfield
 * (C) 2003-2005 Theodore Kisner
 * (C) 2005-2008 D. V. Wiebe
 *
 ***************************************************************************
 *
 * This file is part of the GetData project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GetData is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GetData; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef GETDATA_H
#define GETDATA_H

/* one or more of these should give us:
 *    size_t, off_t, __REDIRECT, &c. 
 */
#include <sys/types.h>
#include <unistd.h>

#define DIRFILE_STANDARDS_VERSION 6

/* ICC ignores the __nonnull__ attribute */
#ifdef __INTEL_COMPILER
# define __gd_nonnull(...)
#else
# define __gd_nonnull __nonnull
#endif

/* if these haven't been defined by the above includes, define them now */
#ifndef __attribute_deprecated__
# define __attribute_deprecated__
#endif
#ifndef __THROW
# define __THROW
#endif
#ifndef __nonnull
# define __nonnull(...)
#endif

/* error codes */
#define GD_E_OK                0 /* this must be zero */
#define GD_E_OPEN              1
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_TYPE          6
#define GD_E_RAW_IO            7
#define GD_E_OPEN_INCLUDE      8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_EMPTY            10
#define GD_E_ALLOC            11
#define GD_E_RANGE            12
#define GD_E_OPEN_LINFILE     13
#define GD_E_RECURSE_LEVEL    14
#define GD_E_BAD_DIRFILE      15
#define GD_E_BAD_FIELD_TYPE   16
#define GD_E_ACCMODE          17
#define GD_E_UNSUPPORTED      18
#define GD_E_UNKNOWN_ENCODING 19
#define GD_E_BAD_ENTRY        20
#define GD_E_DUPLICATE        21
#define GD_E_DIMENSION        22
#define GD_E_BAD_INDEX        23

#define GD_N_ERROR_CODES      24

#define GD_MAX_LINCOM 3

#define GD_SCALAR_ENTRY 0x100
/* field types */
typedef enum {
  GD_NO_ENTRY       = 0x00,
  GD_RAW_ENTRY      = 0x01,
  GD_LINCOM_ENTRY   = 0x02,
  GD_LINTERP_ENTRY  = 0x03,
  GD_BIT_ENTRY      = 0x04,
  GD_MULTIPLY_ENTRY = 0x05,
  GD_PHASE_ENTRY    = 0x06,
  GD_INDEX_ENTRY    = 0x07,
  GD_CONST_ENTRY    = GD_SCALAR_ENTRY + 0x01,
  GD_STRING_ENTRY   = GD_SCALAR_ENTRY + 0x02,
} gd_entype_t;

/* Data types -- No valid type may contain 0x40.  This will automatically
 * invalidate any attempt to use the old-style character types as gd_type_t's */
#define GD_SIZE8     0x01
#define GD_SIZE16    0x02
#define GD_SIZE32    0x04
#define GD_SIZE64    0x08
#define GD_SIZE(x)   (x & 0x0f)

#define GD_SIGNED    0x10
#define GD_IEEE754   0x20

typedef enum {
  GD_NULL    = 0,
  GD_UNKNOWN = 0xb0,  /* GD_SIZE(GD_UNKNOWN) must evaluate to zero */
  GD_UINT8   = GD_SIZE8,
  GD_INT8    = GD_SIZE8  | GD_SIGNED,
  GD_UINT16  = GD_SIZE16,
  GD_INT16   = GD_SIZE16 | GD_SIGNED,
  GD_UINT32  = GD_SIZE32,
  GD_INT32   = GD_SIZE32 | GD_SIGNED,
  GD_UINT64  = GD_SIZE64,
  GD_INT64   = GD_SIZE64 | GD_SIGNED,
  GD_FLOAT32 = GD_SIZE32 | GD_IEEE754,
  GD_FLOAT64 = GD_SIZE64 | GD_IEEE754
} gd_type_t;
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

struct _gd_private_entry;

/* Unified entry struct */
struct _gd_unified_entry {
  char* field;
  gd_entype_t field_type;
  char *in_fields[GD_MAX_LINCOM];
  int format_file;
  union {
    struct { /* RAW */
      unsigned int spf;
      gd_type_t data_type;
      size_t size;
    };
    struct { /* LINCOM */
      int n_fields;
      double m[GD_MAX_LINCOM];
      double b[GD_MAX_LINCOM];
    };
    char* table; /* LINTERP */
    struct { /* BIT */
      int bitnum;
      int numbits;
    };
    int shift; /* PHASE */
    gd_type_t const_type; /* CONST */
  };

  struct _gd_private_entry *e;
};

typedef struct _gd_unified_entry gd_entry_t;

/* The dirifle object */
typedef struct _GD_DIRFILE DIRFILE;

/* dirfile_flags */
#define GD_ACCMODE        0x0001 /* mask */
#define GD_RDONLY         0x0000 /* open read only */
#define GD_RDWR           0x0001 /* open read/write */

#define GD_FORCE_ENDIAN   0x0002 /* override endianness */
#define GD_BIG_ENDIAN     0x0004 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN  0x0008 /* assume litte-endian raw data */
#define GD_CREAT          0x0010 /* create the dirfile if it doesn't exist */
#define GD_EXCL           0x0020 /* force creation: fail on existence */
#define GD_TRUNC          0x0040 /* truncate dirfile (scary!) */
#define GD_PEDANTIC       0x0080 /* be pedantic */
#define GD_FORCE_ENCODING 0x0100 /* override encoding scheme */

#define GD_ENCODING       0xF000 /* mask */
#define GD_AUTO_ENCODED   0x0000 /* Encoding scheme unknown */
#define GD_UNENCODED      0x1000 /* Dirfile is not encoded */
#define GD_TEXT_ENCODED   0x2000 /* Dirfile is text encoded */
#define GD_SLIM_ENCODED   0x3000 /* Dirfile is slimlib encoded */

extern char* get_error_string(const DIRFILE* dirfile, char* buffer,
    size_t buflen) __THROW __gd_nonnull ((1, 2));

extern unsigned int get_spf(DIRFILE* dirfile, const char *field_code) __THROW
__gd_nonnull ((1, 2));

extern unsigned int get_nvectors(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern unsigned int get_nfields(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern unsigned int get_nfields_by_type(DIRFILE* D, gd_entype_t type)
  __THROW __gd_nonnull ((1));

extern const char** get_constant_list(DIRFILE* dirfile)
  __THROW __gd_nonnull ((1));

extern const void* get_constant_values(DIRFILE* dirfile, gd_type_t return_type)
  __THROW __gd_nonnull ((1));

extern const char** get_field_list(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern const char** get_string_list(DIRFILE* dirfile) __THROW __gd_nonnull((1));

extern const char** get_string_values(DIRFILE* dirfile)
  __THROW __gd_nonnull ((1));

extern const char** get_vector_list(DIRFILE* dirfile) __THROW __gd_nonnull((1));

extern int get_entry(DIRFILE* D, const char* field_code, gd_entry_t* entry)
  __THROW __gd_nonnull ((1, 2));

extern gd_entry_t *dirfile_free_entry_strings(gd_entry_t *entry) __THROW;

extern int dirfile_add_meta(DIRFILE* D, gd_entry_t* entry, const char* parent)
  __THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_lincom(DIRFILE* D, const char* field_code, int n_fields,
    const char** in_fields, const double* m, const double* b, int format_file)
__THROW __gd_nonnull ((1,2,4,5,6));

extern int dirfile_add_linterp(DIRFILE* D, const char* field_code,
    const char* in_field, const char* table, int format_file)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_bit(DIRFILE* D, const char* field_code,
    const char* in_field, int bitnum, int numbits, int format_file)
__THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_multiply(DIRFILE* D, const char* field_code,
    const char* in_field1, const char* in_field2, int format_file)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_phase(DIRFILE* D, const char* field_code,
    const char* in_field, int shift, int format_file)
__THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_string(DIRFILE* D, const char* field_code,
    const char* value, int format_file) __THROW __gd_nonnull((1,2,3));

extern int dirfile_add_const(DIRFILE* D, const char* field_code,
    gd_type_t const_type, gd_type_t data_type, const void* value,
    int format_file);

extern int dirfile_add_metalincom(DIRFILE* D, const char* parent,
    const char* field_code, int n_fields, const char** in_fields,
    const double* m, const double* b) __THROW __gd_nonnull((1,2,3,5,6,7));

extern int dirfile_add_metalinterp(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, const char* table)
__THROW __gd_nonnull ((1,2,3,4,5));

extern int dirfile_add_metabit(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, int bitnum, int numbits)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_metamultiply(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field1, const char* in_field2)
__THROW __gd_nonnull ((1,2,3,4,5));

extern int dirfile_add_metaphase(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, int shift)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_metastring(DIRFILE* D, const char* parent,
    const char* field_code, const char* value) __THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_metaconst(DIRFILE* D, const char* parent,
    const char* field_code, gd_type_t const_type, gd_type_t data_type,
    const void* value) __THROW __gd_nonnull ((1,2,3,6));

extern const char* get_format_filename(DIRFILE* D, int index)
  __THROW __gd_nonnull((1));

extern int get_error(const DIRFILE* D) __THROW __gd_nonnull ((1));

extern int get_nformats(DIRFILE* D) __THROW __gd_nonnull((1));

extern size_t put_string(DIRFILE* D, const char *field_code, const char
    *data_in) __THROW __gd_nonnull ((1, 2, 3));

extern size_t put_constant(DIRFILE* D, const char *field_code,
    gd_type_t data_type, const void *data_in) __THROW __gd_nonnull ((1, 2, 4));

unsigned int get_nmeta_fields(DIRFILE* D, const char* parent);

unsigned int get_nmeta_vectors(DIRFILE* D, const char* parent);

unsigned int get_nmeta_fields_by_type(DIRFILE* D, const char* parent,
    gd_entype_t type);

const void* get_metaconstant_values(DIRFILE* D, const char* parent,
    gd_type_t return_type);

const char** get_metaconstant_list(DIRFILE* D, const char* parent);

const char** get_metastring_values(DIRFILE* D, const char* parent);

const char** get_metastring_list(DIRFILE* D, const char* parent);

const char** get_metavector_list(DIRFILE* D, const char* parent);

const char** get_metafield_list(DIRFILE* D, const char* parent);

/* The following functions contain calls to I/O functions, making them
 * cancellation points.  As a result we cannot mark them with __THROW.
 */
extern DIRFILE* dirfile_open(const char* dirfilename, unsigned int flags)
  __gd_nonnull ((1));

extern int dirfile_close(DIRFILE* dirfile);

extern void dirfile_flush(DIRFILE* dirfile, const char* field_code)
  __gd_nonnull ((1));

extern void dirfile_flush_metadata(DIRFILE* dirfile) __gd_nonnull ((1));

extern int dirfile_add_raw(DIRFILE* D, const char* field_code,
    gd_type_t data_type, unsigned int spf, int format_file) __gd_nonnull((1,2));

extern int dirfile_add(DIRFILE* D, const gd_entry_t* entry) __gd_nonnull((1,2));

extern int dirfile_add_spec(DIRFILE* D, int format_file, const char* line)
  __gd_nonnull ((1,3));

extern int dirfile_add_metaspec(DIRFILE* D, const char* parent,
    const char* line) __gd_nonnull ((1,2,3));

/* the following functions are _FILE_OFFSET_BITS sensitive */
#ifndef __USE_FILE_OFFSET64
extern off_t get_nframes(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t return_type,
    void *data_out) __gd_nonnull ((1, 2));

extern size_t putdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#else
# ifdef __REDIRECT_NTH
extern off_t __REDIRECT_NTH (get_nframes, (DIRFILE* dirfile), get_nframes64);
# else
#  define get_nframes get_nframes64
# endif

# ifdef __REDIRECT
extern size_t __REDIRECT (getdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_samp, size_t num_frames,
      size_t num_samp, gd_type_t return_type, void *data_out),
    getdata64) __gd_nonnull ((1, 2));

extern size_t __REDIRECT (putdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_sample, size_t num_frames,
      size_t num_samples, gd_type_t data_type, const void *data_in),
    putdata64) __gd_nonnull ((1, 2));
# else
#  define getdata getdata64
#  define putdata putdata64
# endif
#endif

/* if requested, declare the LFS transitional extension */
#ifdef __USE_LARGEFILE64
extern __off64_t get_nframes64(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_samp, size_t num_frames,
    size_t num_samp, gd_type_t return_type, void *data_out)
__gd_nonnull ((1, 2));

extern size_t putdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#endif

/* The caller can disable the legacy API by defining GETDATA_NO_LEGACY_API
 * before including getdata.h
 */
#ifndef NO_GETDATA_LEGACY_API

/* If this symbol is defined here, the legacy API is present in the library */
#undef GETDATA_LEGACY_API

#endif

/* include the legacy api, if present */
#ifdef GETDATA_LEGACY_API
#include <getdata_legacy.h>
#endif

#endif
