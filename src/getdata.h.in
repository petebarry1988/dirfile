/* (C) 2002-2005 C. Barth Netterfield
 * (C) 2003-2005 Theodore Kisner
 * (C) 2005-2008 D. V. Wiebe
 *
 ***************************************************************************
 *
 * This file is part of the GetData project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GetData is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GetData; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef GETDATA_H
#define GETDATA_H

/* one or more of these should give us:
 *    size_t, off_t, __REDIRECT, &c. 
 */
#include <sys/types.h>
#include <unistd.h>

#define DIRFILE_STANDARDS_VERSION 6

/* ICC ignores the __nonnull__ attribute */
#ifdef __INTEL_COMPILER
# define __gd_nonnull(...)
#else
# define __gd_nonnull __nonnull
#endif

/* if these haven't been defined by the above includes, define them now */
#ifndef __attribute_deprecated__
# define __attribute_deprecated__
#endif
#ifndef __THROW
# define __THROW
#endif
#ifndef __nonnull
# define __nonnull(...)
#endif

/* error codes */
#define GD_E_OK                0 /* this must be zero */
#define GD_E_OPEN              1
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_TYPE          6
#define GD_E_RAW_IO            7
#define GD_E_OPEN_INCLUDE      8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_ALLOC            10
#define GD_E_RANGE            11
#define GD_E_OPEN_LINFILE     12
#define GD_E_RECURSE_LEVEL    13
#define GD_E_BAD_DIRFILE      14
#define GD_E_BAD_FIELD_TYPE   15
#define GD_E_ACCMODE          16
#define GD_E_UNSUPPORTED      17
#define GD_E_UNKNOWN_ENCODING 18
#define GD_E_BAD_ENTRY        19
#define GD_E_DUPLICATE        20
#define GD_E_DIMENSION        21
#define GD_E_BAD_INDEX        22
#define GD_E_BAD_SCALAR       23
#define GD_E_BAD_REFERENCE    24
#define GD_E_PROTECTED        25
#define GD_E_DELETE           26
#define GD_E_BAD_ENDIANNESS   27

#define GD_N_ERROR_CODES      28

/* maximum length of a format file line */
#define GD_MAX_LINE_LENGTH  4096

#define GD_MAX_LINCOM 3

/* syntax suberrors */
#define GD_E_FORMAT_BAD_SPF    1
#define GD_E_FORMAT_N_FIELDS   2
#define GD_E_FORMAT_N_TOK      3
#define GD_E_FORMAT_NUMBITS    4
#define GD_E_FORMAT_BITNUM     5
#define GD_E_FORMAT_BITSIZE    6
#define GD_E_FORMAT_CHARACTER  7
#define GD_E_FORMAT_BAD_LINE   8
#define GD_E_FORMAT_RES_NAME   9
#define GD_E_FORMAT_ENDIAN    10
#define GD_E_FORMAT_BAD_TYPE  11
#define GD_E_FORMAT_BAD_NAME  12
#define GD_E_FORMAT_UNTERM    13
#define GD_E_FORMAT_METARAW   14
#define GD_E_FORMAT_NO_PARENT 15
#define GD_E_FORMAT_DUPLICATE 16
#define GD_E_FORMAT_LOCATION  17
#define GD_E_FORMAT_PROTECT   18

/* this must be one less than the lowest allowed fragment index */
#define GD_ALL_FRAGMENTS -1

#define GD_SCALAR_ENTRY 0x100
/* field types */
typedef enum {
  GD_NO_ENTRY       = 0x00,
  GD_RAW_ENTRY      = 0x01,
  GD_LINCOM_ENTRY   = 0x02,
  GD_LINTERP_ENTRY  = 0x03,
  GD_BIT_ENTRY      = 0x04,
  GD_MULTIPLY_ENTRY = 0x05,
  GD_PHASE_ENTRY    = 0x06,
  GD_INDEX_ENTRY    = 0x07,
  GD_CONST_ENTRY    = GD_SCALAR_ENTRY + 0x01,
  GD_STRING_ENTRY   = GD_SCALAR_ENTRY + 0x02,
} gd_entype_t;

/* GD_NO_ENTRY is not part of this count */
#define GD_N_ENTYPES 9

/* Data types -- No valid type may contain 0x40.  This will automatically
 * invalidate any attempt to use the old-style character types as gd_type_t's */
#define GD_SIZE8     0x01
#define GD_SIZE16    0x02
#define GD_SIZE32    0x04
#define GD_SIZE64    0x08
#define GD_SIZE(x)   (x & 0x0f)

#define GD_SIGNED    0x10
#define GD_IEEE754   0x20

typedef enum {
  GD_NULL    = 0,
  GD_UNKNOWN = 0xb0,  /* GD_SIZE(GD_UNKNOWN) must evaluate to zero */
  GD_UINT8   = GD_SIZE8,
  GD_INT8    = GD_SIZE8  | GD_SIGNED,
  GD_UINT16  = GD_SIZE16,
  GD_INT16   = GD_SIZE16 | GD_SIGNED,
  GD_UINT32  = GD_SIZE32,
  GD_INT32   = GD_SIZE32 | GD_SIGNED,
  GD_UINT64  = GD_SIZE64,
  GD_INT64   = GD_SIZE64 | GD_SIGNED,
  GD_FLOAT32 = GD_SIZE32 | GD_IEEE754,
  GD_FLOAT64 = GD_SIZE64 | GD_IEEE754
} gd_type_t;
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

struct _gd_private_entry;

/* Unified entry struct */
struct _gd_unified_entry {
  char *field;
  gd_entype_t field_type;
  char *in_fields[GD_MAX_LINCOM];
  int fragment_index;
  union {
    struct { /* RAW */
      unsigned int spf;
      gd_type_t data_type;
    };
    struct { /* LINCOM */
      int n_fields;
      double m[GD_MAX_LINCOM];
      double b[GD_MAX_LINCOM];
    };
    char *table; /* LINTERP */
    struct { /* BIT */
      int bitnum;
      int numbits;
    };
    int shift; /* PHASE */
    gd_type_t const_type; /* CONST */
  };

  struct _gd_private_entry *e;
};

typedef struct _gd_unified_entry gd_entry_t;

/* The dirifle object */
typedef struct _GD_DIRFILE DIRFILE;

/* dirfile_flags */
#define GD_ACCMODE        0x0001 /* mask */
#define GD_RDONLY         0x0000 /* open read only */
#define GD_RDWR           0x0001 /* open read/write */

#define GD_FORCE_ENDIAN   0x0002 /* override endianness */
#define GD_BIG_ENDIAN     0x0004 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN  0x0008 /* assume litte-endian raw data */
#define GD_CREAT          0x0010 /* create the dirfile if it doesn't exist */
#define GD_EXCL           0x0020 /* force creation: fail on existence */
#define GD_TRUNC          0x0040 /* truncate dirfile (scary!) */
#define GD_PEDANTIC       0x0080 /* be pedantic */
#define GD_FORCE_ENCODING 0x0100 /* override encoding scheme */
#define GD_VERBOSE        0x0200 /* be verbose */
#define GD_IGNORE_DUPS    0x0400 /* ignore duplicate fields */

#define GD_ENCODING       0xF000 /* mask */
#define GD_AUTO_ENCODED   0x0000 /* Encoding scheme unknown */
#define GD_UNENCODED      0x1000 /* Dirfile is not encoded */
#define GD_TEXT_ENCODED   0x2000 /* Dirfile is text encoded */
#define GD_SLIM_ENCODED   0x3000 /* Dirfile is slimlib encoded */
#define GD_GZIP_ENCODED   0x4000 /* Dirfile is gzip encoded */

extern char* get_error_string(const DIRFILE* dirfile, char* buffer,
    size_t buflen) __THROW __gd_nonnull ((1, 2));

extern unsigned int get_spf(DIRFILE* dirfile, const char *field_code) __THROW
__gd_nonnull ((1, 2));

extern unsigned int get_nvectors(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern unsigned int get_nfields(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern unsigned int get_nfields_by_type(DIRFILE* D, gd_entype_t type)
  __THROW __gd_nonnull ((1));

extern const void* get_constants(DIRFILE* dirfile, gd_type_t return_type)
  __THROW __gd_nonnull ((1));

extern const char** get_field_list(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern const char** get_field_list_by_type(DIRFILE* D, gd_entype_t type)
  __THROW __gd_nonnull((1));

extern const char** get_strings(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern const char** get_vector_list(DIRFILE* dirfile) __THROW __gd_nonnull((1));

extern int get_entry(DIRFILE* D, const char* field_code, gd_entry_t* entry)
  __THROW __gd_nonnull ((1, 2));

extern gd_entry_t *dirfile_free_entry_strings(gd_entry_t *entry) __THROW;

extern int dirfile_madd(DIRFILE* D, const gd_entry_t* entry, const char* parent)
  __THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_lincom(DIRFILE* D, const char* field_code, int n_fields,
    const char** in_fields, const double* m, const double* b,
    int fragment_index) __THROW __gd_nonnull ((1,2,4,5,6));

extern int dirfile_add_linterp(DIRFILE* D, const char* field_code,
    const char* in_field, const char* table, int fragment_index)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_bit(DIRFILE* D, const char* field_code,
    const char* in_field, int bitnum, int numbits, int fragment_index)
__THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_multiply(DIRFILE* D, const char* field_code,
    const char* in_field1, const char* in_field2, int fragment_index)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_add_phase(DIRFILE* D, const char* field_code,
    const char* in_field, int shift, int fragment_index)
__THROW __gd_nonnull ((1,2,3));

extern int dirfile_add_string(DIRFILE* D, const char* field_code,
    const char* value, int fragment_index) __THROW __gd_nonnull((1,2,3));

extern int dirfile_add_const(DIRFILE* D, const char* field_code,
    gd_type_t const_type, gd_type_t data_type, const void* value,
    int fragment_index);

extern int dirfile_madd_lincom(DIRFILE* D, const char* parent,
    const char* field_code, int n_fields, const char** in_fields,
    const double* m, const double* b) __THROW __gd_nonnull((1,2,3,5,6,7));

extern int dirfile_madd_linterp(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, const char* table)
__THROW __gd_nonnull ((1,2,3,4,5));

extern int dirfile_madd_bit(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, int bitnum, int numbits)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_madd_multiply(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field1, const char* in_field2)
__THROW __gd_nonnull ((1,2,3,4,5));

extern int dirfile_madd_phase(DIRFILE* D, const char* parent,
    const char* field_code, const char* in_field, int shift)
__THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_madd_string(DIRFILE* D, const char* parent,
    const char* field_code, const char* value) __THROW __gd_nonnull ((1,2,3,4));

extern int dirfile_madd_const(DIRFILE* D, const char* parent,
    const char* field_code, gd_type_t const_type, gd_type_t data_type,
    const void* value) __THROW __gd_nonnull ((1,2,3,6));

extern const char* get_fragmentname(DIRFILE* D, int index)
  __THROW __gd_nonnull((1));

extern int get_error(const DIRFILE* D) __THROW __gd_nonnull ((1));

extern int get_nfragments(DIRFILE* D) __THROW __gd_nonnull((1));

extern int get_constant(DIRFILE* D, const char *field_code,
    gd_type_t return_type, void *data_out) __THROW __gd_nonnull ((1, 2));

extern int put_constant(DIRFILE* D, const char *field_code,
    gd_type_t data_type, const void *data_in) __THROW __gd_nonnull ((1, 2, 4));

extern size_t get_string(DIRFILE* D, const char *field_code, size_t len,
    char *data_in) __THROW __gd_nonnull ((1, 2, 4));

extern size_t put_string(DIRFILE* D, const char *field_code,
    const char *data_in) __THROW __gd_nonnull ((1, 2, 3));

extern unsigned int get_nmfields(DIRFILE* D, const char* parent)
  __THROW __gd_nonnull((1,2));

extern unsigned int get_nmvectors(DIRFILE* D, const char* parent)
  __THROW __gd_nonnull((1,2));

extern unsigned int get_nmfields_by_type(DIRFILE* D, const char* parent,
    gd_entype_t type) __THROW __gd_nonnull((1,2));

extern const void* get_mconstants(DIRFILE* D, const char* parent,
    gd_type_t return_type) __THROW __gd_nonnull((1,2));

extern const char** get_mstrings(DIRFILE* D, const char* parent)
  __THROW __gd_nonnull((1,2));

extern const char** get_mfield_list_by_type(DIRFILE* D, const char* parent,
    gd_entype_t type) __THROW __gd_nonnull((1,2));

extern const char** get_mvector_list(DIRFILE* D, const char* parent)
  __THROW __gd_nonnull((1,2));

extern const char** get_mfield_list(DIRFILE* D, const char* parent)
  __THROW __gd_nonnull((1,2));

extern int dirfile_madd_spec(DIRFILE* D, const char* line, const char* parent)
  __THROW __gd_nonnull ((1,2,3));

extern const char* get_raw_filename(DIRFILE* D, const char* field_code)
  __THROW __gd_nonnull ((1, 2));

extern int put_reference(DIRFILE* D, const char* field_code) __THROW
__gd_nonnull ((1, 2));

extern const char* dirfilename(DIRFILE* D) __THROW __gd_nonnull ((1));

extern const char* get_reference(DIRFILE* D) __THROW __gd_nonnull ((1));

extern int dirfile_change_lincom(DIRFILE* D, const char* field_code,
    int n_fields, const char** in_fields, const double* m, const double* b)
__THROW __gd_nonnull((1,2));

extern int dirfile_change_bit(DIRFILE* D, const char* field_code,
    const char* in_field, int bitnum, int numbits) __THROW __gd_nonnull((1,2));

extern int dirfile_change_multiply(DIRFILE* D, const char* field_code,
    const char* in_field1, const char* in_field2) __THROW __gd_nonnull((1,2));

extern int dirfile_change_phase(DIRFILE* D, const char* field_code,
    const char* in_field, int shift) __THROW __gd_nonnull((1,2));

extern int dirfile_change_const(DIRFILE* D, const char* field_code,
    gd_type_t const_type) __THROW __gd_nonnull((1,2));

/* The following functions contain calls to I/O functions, making them
 * cancellation points.  As a result we cannot mark them with __THROW.
 */
extern DIRFILE* dirfile_open(const char* dirfilename,
    unsigned int flags) __gd_nonnull ((1));

extern int dirfile_include(DIRFILE* D, const char* file, int fragment_index,
    unsigned int flags) __gd_nonnull ((1,2));

extern int dirfile_close(DIRFILE* dirfile);

extern int dirfile_flush(DIRFILE* dirfile,
    const char* field_code) __gd_nonnull ((1));

extern int dirfile_metaflush(DIRFILE* dirfile) __gd_nonnull ((1));

extern int dirfile_add_raw(DIRFILE* D, const char* field_code,
    gd_type_t data_type, unsigned int spf, int fragment_index)
__gd_nonnull((1,2));

extern int dirfile_add(DIRFILE* D, const gd_entry_t* entry) __gd_nonnull((1,2));

extern int dirfile_add_spec(DIRFILE* D, const char* line,
    int fragment_index) __gd_nonnull ((1,2));

extern int put_encoding(DIRFILE* D, unsigned int encoding, int fragment,
    int move) __gd_nonnull ((1));

/* delete flags */
#define GD_DEL_NONE  0x0
#define GD_DEL_META  0x1
#define GD_DEL_DATA  0x2
#define GD_DEL_DEREF 0x4
#define GD_DEL_FORCE 0x8
extern int dirfile_delete(DIRFILE* D, const char* field_code,
    int flags) __gd_nonnull ((1,2));

extern int dirfile_change(DIRFILE* D, const char* field_code,
    const gd_entry_t *entry, int move) __gd_nonnull ((1,2));

extern int dirfile_change_raw(DIRFILE *D, const char *field_code,
    unsigned int spf, gd_type_t data_type, int move) __gd_nonnull ((1,2));

extern int dirfile_change_linterp(DIRFILE* D, const char* field_code,
    const char* in_field, const char* table, int move) __gd_nonnull ((1,2));

extern int dirfile_change_spec(DIRFILE* D, const char* line,
    int move) __gd_nonnull ((1,2));

extern int dirfile_mchange_spec(DIRFILE* D, const char* parent,
    const char* line, int move) __gd_nonnull ((1,2,3));

/* the following functions are _FILE_OFFSET_BITS sensitive */
#ifndef __USE_FILE_OFFSET64
extern off_t get_frameoffset(DIRFILE* dirfile, int fragment)
  __THROW __gd_nonnull ((1));

extern off_t get_nframes(DIRFILE* dirfile) __gd_nonnull ((1));

extern size_t getdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t return_type,
    void *data_out) __gd_nonnull ((1, 2));

extern size_t putdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));

extern int put_frameoffset(DIRFILE* D, off_t field_code, int fragment,
    int move) __gd_nonnull ((1));
#else
# ifdef __REDIRECT_NTH
extern off_t __REDIRECT_NTH (get_frameoffset, (DIRFILE* dirfile, int fragment),
    get_frameoffset64) __gd_nonnull ((1));
# else
#  define get_frameoffset get_frameoffset64
# endif

# ifdef __REDIRECT
extern off_t __REDIRECT (get_nframes, (DIRFILE* dirfile),
    get_nframes64) __gd_nonnull ((1));

extern size_t __REDIRECT (getdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_samp, size_t num_frames,
      size_t num_samp, gd_type_t return_type, void *data_out),
    getdata64) __gd_nonnull ((1, 2));

extern size_t __REDIRECT (putdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_sample, size_t num_frames,
      size_t num_samples, gd_type_t data_type, const void *data_in),
    putdata64) __gd_nonnull ((1, 2));

extern int __REDIRECT (put_frameoffset, (DIRFILE* D, __off64_t offset,
      int fragment, int move), put_frameoffset64) __gd_nonnull ((1));
# else
#  define get_nframes get_nframes64
#  define getdata getdata64
#  define putdata putdata64
#  define put_frameoffset put_frameoffset64
# endif
#endif

/* if requested, declare the LFS transitional extension */
#ifdef __USE_LARGEFILE64
extern __off64_t get_frameoffset64(DIRFILE* dirfile,
    int fragment) __gd_nonnull ((1));

extern __off64_t get_nframes64(DIRFILE* dirfile) __gd_nonnull ((1));

extern int put_frameoffset64(DIRFILE* D, __off64_t field_code, int fragment,
    int move) __gd_nonnull ((1));

extern size_t getdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_samp, size_t num_frames,
    size_t num_samp, gd_type_t return_type, void *data_out)
__gd_nonnull ((1, 2));

extern size_t putdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#endif

/* The caller can disable the legacy API by defining GETDATA_NO_LEGACY_API
 * before including getdata.h
 */
#ifndef NO_GETDATA_LEGACY_API

/* If this symbol is defined here, the legacy API is present in the library */
#undef GETDATA_LEGACY_API

#endif

/* include the legacy api, if present */
#ifdef GETDATA_LEGACY_API
#include <getdata_legacy.h>
#endif

#endif
