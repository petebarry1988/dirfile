/* (C) 2002-2005 C. Barth Netterfield
 * (C) 2003-2005 Theodore Kisner
 * (C) 2005-2008 D. V. Wiebe
 *
 ***************************************************************************
 *
 * This file is part of the GetData project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GetData is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GetData; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef GETDATA_H
#define GETDATA_H

/* one or more of these should give us:
 *    size_t, off_t, __REDIRECT, &c. 
 */
#include <sys/types.h>
#include <unistd.h>

/* For FILENAME_MAX */
#include <stdio.h>

#define DIRFILE_STANDARDS_VERSION 5

/* ICC ignores the __nonnull__ attribute */
#ifdef __INTEL_COMPILER
# define __gd_nonnull(...)
#else
# define __gd_nonnull __nonnull
#endif

/* if these haven't been defined by the above includes, define them now */
#ifndef __attribute_deprecated__
# define __attribute_deprecated__
#endif
#ifndef __THROW
# define __THROW
#endif
#ifndef __nonnull
# define __nonnull(...)
#endif

/* error codes */
#define GD_E_OK                0 /* this must be zero */
#define GD_E_OPEN              1
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_TYPE          6
#define GD_E_RAW_IO            7
#define GD_E_OPEN_INCLUDE      8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_EMPTY            10
#define GD_E_ALLOC            11
#define GD_E_RANGE            12
#define GD_E_OPEN_LINFILE     13
#define GD_E_RECURSE_LEVEL    14
#define GD_E_BAD_DIRFILE      15
#define GD_E_BAD_PUT_FIELD    16
#define GD_E_ACCMODE          17
#define GD_E_BAD_ENTRY        18
#define GD_E_DUPLICATE        19

#define GD_N_ERROR_CODES      20

#ifndef FILENAME_MAX
#  define FILENAME_MAX 4096
#endif
#define GD_MAX_LINCOM 3

/* field types */
typedef enum {
  GD_NO_ENTRY = 0, GD_RAW_ENTRY, GD_LINCOM_ENTRY, GD_LINTERP_ENTRY,
  GD_BIT_ENTRY, GD_MULTIPLY_ENTRY, GD_PHASE_ENTRY
} gd_entype_t;

/* Data types -- No valid type may contain 0x40.  This will automatically
 * invalidate any attempt to use the old-style character types as gd_type_t's */
#define GD_SIZE8     0x01
#define GD_SIZE16    0x02
#define GD_SIZE32    0x04
#define GD_SIZE64    0x08
#define GD_SIZE(x)   (x & 0x0f)

#define GD_SIGNED    0x10
#define GD_IEEE754   0x20

typedef enum {
  GD_NULL    = 0,
  GD_UNKNOWN = 0xb0,  /* GD_SIZE(GD_UNKNOWN) must evaluate to zero */
  GD_UINT8   = GD_SIZE8,
  GD_INT8    = GD_SIZE8  | GD_SIGNED,
  GD_UINT16  = GD_SIZE16,
  GD_INT16   = GD_SIZE16 | GD_SIGNED,
  GD_UINT32  = GD_SIZE32,
  GD_INT32   = GD_SIZE32 | GD_SIGNED,
  GD_UINT64  = GD_SIZE64,
  GD_INT64   = GD_SIZE64 | GD_SIGNED,
  GD_FLOAT32 = GD_SIZE32 | GD_IEEE754,
  GD_FLOAT64 = GD_SIZE64 | GD_IEEE754
} gd_type_t;
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

/* Unified entry struct */
struct _gd_unified_entry {
  char* field;
  gd_entype_t field_type;
  char *in_fields[GD_MAX_LINCOM];
  union {
    struct { /* RAW */
      unsigned int spf;
      gd_type_t data_type;
      size_t size;

      char* file; /* intenral */
      int fp; /* intenral */
    };
    struct { /* LINCOM */
      int n_fields;
      double m[GD_MAX_LINCOM];
      double b[GD_MAX_LINCOM];
    };
    struct { /* LINTERP */
      char* table;

      int table_len; /* internal */
      double* x; /* internal */
      double* y; /* internal */
    };
    struct { /* BIT */
      int bitnum;
      int numbits;
    };
    int shift; /* PHASE */
  };
};

typedef struct _gd_unified_entry gd_entry_t;

/* The DIRFILE struct.  */
struct _GD_DIRFILE {
  /* Error reporting -- this is the only public member. */
  int error;

  /* Everything below this comment should be considered internal to the library
   * and not part of the official API */

  /* field count */
  unsigned int n_entries;

  /* field array */
  gd_entry_t** entry;

  /* The first field */
  gd_entry_t* first_field;

  /* directory name */
  const char* name;

  /* recursion counter */
  int recurse_level;

  /* field list */
  const char** field_list;

#ifndef __USE_FILE_OFFSET64
  off_t
#else
    __off64_t
#endif
    frame_offset;
  int suberror;
  char* error_string;
  char* error_file;
  int error_line;
  int flags;
};

typedef struct _GD_DIRFILE DIRFILE;

/* dirfile_flags */
#define GD_ACCMODE            03
#define GD_RDONLY             00 /* open read only */
#define GD_RDWR               02 /* open read/write */
#define GD_CREAT            0100 /* create the dirfile if it doesn't exist */
#define GD_EXCL             0200 /* force creation: fail on existence */
#define GD_TRUNC           01000 /* truncate dirfile (scary!) */
#define GD_BIG_ENDIAN    0200000 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN 0400000 /* assume litte-endian raw data */
#define GD_FORCE_ENDIAN 01000000 /* override endianness */
#define GD_PEDANTIC     02000000 /* be pedantic */
#define GD_INVALID      04000000 /* the dirfile is invalid */

extern char* get_error_string(const DIRFILE* dirfile, char* buffer,
    size_t buflen) __THROW __gd_nonnull ((1, 2));

extern unsigned int get_spf(DIRFILE* dirfile, const char *field_code) __THROW
__gd_nonnull ((1, 2));

extern unsigned int get_nfields(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern const char** get_field_list(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

int get_entry(DIRFILE* D, const char* field_code, gd_entry_t* entry)
  __THROW __gd_nonnull ((1, 2));

gd_entry_t *dirfile_free_entry_strings(gd_entry_t *entry) __THROW;

int dirfile_add(DIRFILE* D, const gd_entry_t* entry)
  __THROW __gd_nonnull ((1,2));

int dirfile_add_raw(DIRFILE* D, const char* field_code, unsigned int spf,
    gd_type_t data_type) __THROW __gd_nonnull ((1,2));

int dirfile_add_lincom(DIRFILE* D, const char* field_code, int n_fields, ...)
  __THROW __gd_nonnull ((1,2));

int dirfile_add_linterp(DIRFILE* D, const char* field_code,
    const char* in_field, const char* table) __THROW __gd_nonnull ((1,2,3,4));

int dirfile_add_bit(DIRFILE* D, const char* field_code, const char* in_field,
    int bitnum, int numbits) __THROW __gd_nonnull ((1,2,3));

int dirfile_add_multiply(DIRFILE* D, const char* field_code,
    const char* in_field1, const char* in_field2) __THROW
__gd_nonnull ((1,2,3,4));

int dirfile_add_phase(DIRFILE* D, const char* field_code, const char* in_field,
    int shift) __THROW __gd_nonnull ((1,2,3));

/* The following functions contain calls to I/O functions, making them
 * cancellation points.  As a result we cannot mark them with __THROW.
 */
extern DIRFILE* dirfile_open(const char* dirfilename, unsigned int flags)
  __gd_nonnull ((1));

extern int dirfile_close(DIRFILE* dirfile);

extern void dirfile_flush(DIRFILE* dirfile, const char* field_code)
  __gd_nonnull ((1));

/* the following functions are _FILE_OFFSET_BITS sensitive */
#ifndef __USE_FILE_OFFSET64
extern off_t get_nframes(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t return_type,
    void *data_out) __gd_nonnull ((1, 2));

extern size_t putdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#else
# ifdef __REDIRECT_NTH
extern off_t __REDIRECT_NTH (get_nframes, (DIRFILE* dirfile), get_nframes64);
# else
#  define get_nframes get_nframes64
# endif

# ifdef __REDIRECT
extern size_t __REDIRECT (getdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_samp, size_t num_frames,
      size_t num_samp, gd_type_t return_type, void *data_out),
    getdata64) __gd_nonnull ((1, 2));

extern size_t __REDIRECT (putdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_sample, size_t num_frames,
      size_t num_samples, gd_type_t data_type, const void *data_in),
    putdata64) __gd_nonnull ((1, 2));
# else
#  define getdata getdata64
#  define putdata putdata64
# endif
#endif

/* if requested, declare the LFS transitional extension */
#ifdef __USE_LARGEFILE64
extern __off64_t get_nframes64(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_samp, size_t num_frames,
    size_t num_samp, gd_type_t return_type, void *data_out)
__gd_nonnull ((1, 2));

extern size_t putdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#endif

/* The caller can disable the legacy API by defining GETDATA_NO_LEGACY_API
 * before including getdata.h
 */
#ifndef NO_GETDATA_LEGACY_API

/* If this symbol is defined here, the legacy API is present in the library */
#undef GETDATA_LEGACY_API

#endif

/* include the legacy api, if present */
#ifdef GETDATA_LEGACY_API
#include <getdata_legacy.h>
#endif

#endif
