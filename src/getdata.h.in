#ifndef GETDATA_H
#define GETDATA_H

#define DIRFILE_STANDARDS_VERSION 5

#define GD_E_OK                0
#define GD_E_OPEN              1
#define GD_E_OPEN_FORMAT       (GD_E_OPEN) /* backwards compatability */
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_RETURN_TYPE   6
#define GD_E_OPEN_RAWFIELD     7
#define GD_E_OPEN_INCLUDE      8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_NO_RAW_FIELDS    10
#define GD_E_ALLOC            11
#define GD_E_NO_RAWFIELDS     12
#define GD_E_OPEN_LINFILE     13
#define GD_E_RECURSE_LEVEL    14
#define GD_E_BAD_DIRFILE      15

#define GD_E_BAD_PUT_CODE     16
#define GD_E_PUT_RAWFIELD     17
#define GD_E_CLOSE_RDONLY     18
#define GD_E_WRITE_LOCK       19
#define GD_E_FLOCK_ALLOC      20
#define GD_E_MULT_LINCOM      21

#define GD_N_ERROR_CODES      22

extern const char *GD_ERROR_CODES[GD_N_ERROR_CODES];

/* For FILENAME_MAX */
#include <stdio.h>

#ifndef FILENAME_MAX
#  define FILENAME_MAX 4096
#endif
#define GD_MAX_LINCOM 3

#define GD_RAW_ENTRY      0
#define GD_LINCOM_ENTRY   1
#define GD_LINTERP_ENTRY  2
#define GD_BIT_ENTRY      3
#define GD_MULTIPLY_ENTRY 4
#define GD_PHASE_ENTRY    5
/* Incomplete, generic entry struct */
struct gd_entry_t {
  const char* field;
  int field_type;
};

/* The DIRFILE struct.  It includes an opaque pointer to the getdata struct,
 * as well as library error data.  .error should be considered the only public
 * member */
struct _GD_DIRFILE {
  /* Error reporting */
  int error;

  /* field count */
  unsigned int n_entries;

  /* field array */
  struct gd_entry_t** entries;

  /* The first field */
  struct gd_entry_t* first_field;

  /* directory name */
  const char* name;

  /* recursion counter */
  int recurse_level;

  int frame_offset;
  int suberror;
  char* error_string;
  char* error_file;
  int error_line;
  int flags;
};

typedef struct _GD_DIRFILE DIRFILE;


/* Data types */
typedef char gd_type_t;
#define GD_UNKNOWN   '\0'
#define GD_NULL      'n'
#define GD_INT8      'c'
#define GD_UINT8     '\1'
#define GD_INT16     's'
#define GD_UINT16    'u'
#define GD_INT32     'S'
#define GD_INT32_ALT 'i' /* for readdata backwards compatibility */
#define GD_UINT32    'U'
#define GD_INT64     '\2'
#define GD_UINT64    '\3'
#define GD_FLOAT32   'f'
#define GD_FLOAT64   'd'
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

/***************************************************************************/
/*                                                                         */
/*    getdata_error_string: Write a descriptive message in the supplied    */
/*    buffer describing the last library error associated with the         */
/*    supplied buffer.  The message may be truncated but will be null      */
/*    terminated.                                                          */
/*                                                                         */
/*      dirfile: the dirfile to check for a library error                  */
/*      buffer : memory into which to write the string                     */
/*      buflen : length of the buffer.  The function will not write        */
/*               more than buflen characters (including the trailing '\0') */
/*                                                                         */
/*    return value: buffer or NULL if buflen < 1                           */
/*                                                                         */
/***************************************************************************/
char* getdata_error_string(DIRFILE* dirfile, char* buffer, size_t buflen);

/***************************************************************************/
/*                                                                         */
/*    dirfile_open: Attempt to open and parse the specified dirfile.       */
/*                                                                         */
/*      dirfilename: The path to the dirfile                               */
/*      flags:       Bitwise or'd flags                                    */
/*                                                                         */
/*    return value: a pointer to a valid, new DIRFILE object.  On, error   */
/*    a valid DIRFILE pointer is still returned, but only the error flags  */
/*    be set.  After both success and failure, the DIRFILE object can be   */
/*    cleaned up by calling dirfile_close.                                 */
/*                                                                         */
/***************************************************************************/
#define GD_CREAT            0100 /* create the dirfile if it doesn't exist */
#define GD_EXCL             0200 /* force creation: fail on existence */
#define GD_TRUNC           01000 /* truncate dirfile (scary!) */
#define GD_BIG_ENDIAN    0200000 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN 0400000 /* assume litte-endian raw data */
#define GD_FORCE_ENDIAN 01000000 /* override endiandess */
#define GD_PEDANTIC     02000000 /* be pedantic */
#define GD_INVALID      04000000 /* the dirfile is invalid */
DIRFILE* dirfile_open(const char* dirfilename, unsigned int flags);

/***************************************************************************/
/*                                                                         */
/*    dirfile_open: Attempt to close the provided dirfile and free.        */
/*                                                                         */
/*      dirfile: The dirfile to close                                      */
/*                                                                         */
/*    return value: none: dirfile_close always succeeds.                   */
/*                                                                         */
/***************************************************************************/
void dirfile_close(DIRFILE* dirfile);

/***************************************************************************/
/*                                                                         */
/*    getdata: Retrieve the specified vector from the supplied dirfile.    */
/*    The deprecated GetData does the dirfile look-up by directory name    */
/*                                                                         */
/*      dirfile            : The dirfile to query                          */
/*      field_code         : The field to return                           */
/*      first_frame, first_samp: the first sample read is                  */
/*                first_samp + samples_per_frame * first_frame             */
/*      num_frames, num_samps: the number of samples read is               */
/*                num_samps + samples_per_frame * num_frames               */
/*      return_type: data type of *data_out:                               */
/*           GD_INT8,  GD_INT16,   GD_INT32,  GD_INT64                     */
/*          GD_UINT8, GD_UINT16,  GD_UINT32, GD_UINT64                     */
/*                               GD_FLOAT32, GD_FLOAT64                    */
/*      data_out: pointer to a sufficiently large area of memory to        */
/*           write the data                                                */
/*                                                                         */
/*    return value: number of samples actually retrieved                   */
/*                                                                         */
/***************************************************************************/
int getdata(DIRFILE* dirfile, const char *field_code, int first_frame,
    int first_samp, int num_frames, int num_samp, gd_type_t return_type,
    void *data_out);

/***************************************************************************/
/*                                                                         */
/*    get_n_frmaes: Return the number of frames in the supplied dirfile.   */
/*                                                                         */
/*      dirfile            : The dirfile to query                          */
/*                                                                         */
/*    return value: the number of frames in the dirfile, or zero on error  */
/*                                                                         */
/***************************************************************************/
unsigned long get_n_frames(DIRFILE* dirfile);


/***************************************************************************/
/*                                                                         */
/*    get_samples_per_frame: Return the number of samples per frame for    */
/*    the given field in the supplied dirfile.                             */
/*                                                                         */
/*      dirfile            : The dirfile to query                          */
/*      field_code         : The field in question                         */
/*                                                                         */
/*    return value: the number of samples per frame for the given field    */
/*      or zero on error                                                   */
/*                                                                         */
/***************************************************************************/
unsigned int get_samples_per_frame(DIRFILE* dirfile, const char *field_code);

/***************************************************************************/
/*                                                                         */
/*    putdata: Store the specified vector from the supplied dirfile.       */
/*    The deprecated GetData does the dirfile look-up by directory name    */
/*                                                                         */
/*      dirfile            : The dirfile to query                          */
/*      field_code         : The field to store                            */
/*      first_frame, first_samp: the first sample written is               */
/*                first_samp + samples_per_frame * first_frame             */
/*      num_frames, num_samps: the number of samples written is            */
/*                num_samps + samples_per_frame * num_frames               */
/*      return_type: data type of *data_in:                                */
/*           GD_INT8,  GD_INT16,   GD_INT32,   GD_INT64                    */
/*          GD_UINT8, GD_UINT16,  GD_UINT32,  GD_UINT64                    */
/*                               GD_FLOAT32, GD_FLOAT64                    */
/*      data_in: pointer to the data to write                              */
/*                                                                         */
/*    return value: number of samples actually stored                      */
/*                                                                         */
/***************************************************************************/
int putdata(DIRFILE* D, const char *field_code, int first_frame, int first_samp,
    int num_frames, int num_samp, gd_type_t data_type, void *data_in);

@INCLUDE_LEGACY@
#endif
