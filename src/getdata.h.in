/* (C) 2002-2005 C. Barth Netterfield
 * (C) 2003-2005 Theodore Kisner
 * (C) 2005-2010 D. V. Wiebe
 *
 ***************************************************************************
 *
 * This file is part of the GetData project.
 *
 * GetData is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * GetData is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GetData; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/* GETDATA.H -- GetData Library public API definition
 * --------------------------------------------------
 *
 * Several preprocessor symbols may be defined before including this file to
 * modify it's use:
 *
 * - defining GD_NO_LEGACY_API will prevent the Legacy API declarations in
 *   getdata_legacy.h from being declared.  If the Legacy API was omitted from
 *   the library when it was built, this symbol does nothing.
 * 
 * - defining GD_C89_API will prevent declarations herein from
 *   using the C99 keyword `_Complex'.  Affected declarations will instead use a
 *   two-element array of doubles in place of the complex types.  This symbol
 *   permits including these declarations using a non-C99 conforming compiler.
 *
 * - defining GD_FUNCTION_ALIASES will result in a number of function aliases
 *   which map the version 0.7 function names to the names used in GetData-0.6.
 *   This feature is provided only to ease transistion, and will be removed in
 *   some unpecified future release.
 */

#ifndef GETDATA_H
#define GETDATA_H

#ifdef __cplusplus
extern "C" {
#endif

/* The most recent standards version supported by this library */
#define GD_DIRFILE_STANDARDS_VERSION 8

/* one or more of these should give us:
 *    size_t, off_t, __REDIRECT, &c., if present
 */
#include <sys/types.h>
#include <unistd.h>

/* If this symbol is defined here, the C99-API is not present in the library */
#undef GD_NO_C99_API

/* define function attributes */
#define gd_gnu_enough ((__GNUC__ * 100 + __GNUC_MINOR__) >= 303)

#ifdef __attribute_deprecated__
# define gd_deprecated __attribute_deprecated__
#elif gd_gnu_enough
# define gd_deprecated __attribute__ ((__deprecated__))
#else
# define gd_deprecated /**/
#endif

#ifdef __THROW
# define gd_nothrow __THROW
#elif !defined __cplusplus && gd_gnu_enough
# define gd_nothrow __attribute__ ((__nothrow__))
#else
# define gd_nothrow /**/
#endif

/* ICC complains that it ignores the __nonnull__ attribute */
#ifdef __INTEL_COMPILER
# define gd_nonnull(...) /**/
#elif defined __nonnull
# define gd_nonnull __nonnull
#elif gd_gnu_enough
# define gd_nonnull(...) __attribute__ ((__nonnull__ __VA_ARGS__))
#else
# define gd_nonnull(...) /**/
#endif

/* error codes */
#define GD_E_OK                0 /* this MUST be zero */
#define GD_E_OPEN              1
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_TYPE          6
#define GD_E_RAW_IO            7
#define GD_E_OPEN_FRAGMENT     8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_ALLOC            10
#define GD_E_RANGE            11
#define GD_E_OPEN_LINFILE     12
#define GD_E_RECURSE_LEVEL    13
#define GD_E_BAD_DIRFILE      14
#define GD_E_BAD_FIELD_TYPE   15
#define GD_E_ACCMODE          16
#define GD_E_UNSUPPORTED      17
#define GD_E_UNKNOWN_ENCODING 18
#define GD_E_BAD_ENTRY        19
#define GD_E_DUPLICATE        20
#define GD_E_DIMENSION        21
#define GD_E_BAD_INDEX        22
#define GD_E_BAD_SCALAR       23
#define GD_E_BAD_REFERENCE    24
#define GD_E_PROTECTED        25
#define GD_E_DELETE           26
#define GD_E_BAD_ENDIANNESS   27
#define GD_E_CALLBACK         28
#define GD_E_BAD_PROTECTION   29
#define GD_E_UNCLEAN_DB       30
#define GD_E_DOMAIN           31
#define GD_E_BAD_REPR         32
#define GD_E_BAD_VERSION      33
#define GD_E_FLUSH            34

#define GD_N_ERROR_CODES      35

/* Deprecated error codes */
#define GD_E_OPEN_INCLUDE      GD_E_OPEN_FRAGMENT

/* maximum length of a format file line */
#define GD_MAX_LINE_LENGTH  4096

#define GD_MAX_LINCOM 3

/* the following MUST be at least one less than twice GD_MAX_LINCOM */
#define GD_MAX_POLYORD (GD_MAX_LINCOM * 2 - 1)

/* syntax suberrors */
#define GD_E_FORMAT_BAD_SPF    1
#define GD_E_FORMAT_N_FIELDS   2
#define GD_E_FORMAT_N_TOK      3
#define GD_E_FORMAT_NUMBITS    4
#define GD_E_FORMAT_BITNUM     5
#define GD_E_FORMAT_BITSIZE    6
#define GD_E_FORMAT_CHARACTER  7
#define GD_E_FORMAT_BAD_LINE   8
#define GD_E_FORMAT_RES_NAME   9
#define GD_E_FORMAT_ENDIAN    10
#define GD_E_FORMAT_BAD_TYPE  11
#define GD_E_FORMAT_BAD_NAME  12
#define GD_E_FORMAT_UNTERM    13
#define GD_E_FORMAT_METARAW   14
#define GD_E_FORMAT_NO_PARENT 15
#define GD_E_FORMAT_DUPLICATE 16
#define GD_E_FORMAT_LOCATION  17
#define GD_E_FORMAT_PROTECT   18
#define GD_E_FORMAT_LITERAL   19

/* parser callback return values */
#define GD_SYNTAX_ABORT    0
#define GD_SYNTAX_RESCAN   1
#define GD_SYNTAX_IGNORE   2
#define GD_SYNTAX_CONTINUE 3

/* Protection levels */
#define GD_PROTECT_NONE   00
#define GD_PROTECT_FORMAT 01
#define GD_PROTECT_DATA   02
#define GD_PROTECT_ALL    ( GD_PROTECT_DATA | GD_PROTECT_FORMAT )

/* Standards specifiers */
#define GD_VERSION_CURRENT  -1
#define GD_VERSION_LATEST   -2
#define GD_VERSION_EARLIEST -3

/* this MUST be one less than the lowest allowed fragment index */
#define GD_ALL_FRAGMENTS -1

#define GD_SCALAR_ENTRY 0x10
/* field types */
typedef enum {
  GD_NO_ENTRY       = 0x00,
  GD_RAW_ENTRY      = 0x01,
  GD_LINCOM_ENTRY   = 0x02,
  GD_LINTERP_ENTRY  = 0x03,
  GD_BIT_ENTRY      = 0x04,
  GD_MULTIPLY_ENTRY = 0x05,
  GD_PHASE_ENTRY    = 0x06,
  GD_INDEX_ENTRY    = 0x07,
  GD_POLYNOM_ENTRY  = 0x08,
  GD_SBIT_ENTRY     = 0x09,
  GD_DIVIDE_ENTRY   = 0x0A,
  GD_RECIP_ENTRY    = 0x0B,
  GD_CONST_ENTRY    = GD_SCALAR_ENTRY | 0x00,
  GD_STRING_ENTRY   = GD_SCALAR_ENTRY | 0x01
} gd_entype_t;

/* GD_NO_ENTRY is not part of this count */
#define GD_N_ENTYPES 13

#undef _gd_int16_t
#undef _gd_uint16_t
#undef _gd_int64_t
#if ! defined GD_C89_API && ! defined GD_NO_C99_API
#  include <inttypes.h>
#  define GD_DCOMPLEXM(v) double _Complex v
#  define GD_DCOMPLEXP(v) double _Complex *v
typedef int16_t gd_bit_t;
typedef uint16_t gd_spf_t;
typedef int64_t gd_shift_t;
#else
#  define GD_DCOMPLEXM(v) double v[2]
#  define GD_DCOMPLEXP(v) double *v
typedef _gd_int16_t gd_bit_t;
typedef _gd_uint16_t gd_spf_t;
typedef _gd_int64_t gd_shift_t;
#endif

/* Data types -- No valid type may set 0x40 */
#define GD_SIZE8     0x001
#define GD_SIZE16    0x002
#define GD_SIZE32    0x004
#define GD_SIZE64    0x008
#define GD_SIZE128   0x010
#define GD_SIZE(x)   (x & 0x01f)

#define GD_SIGNED    0x020
#define GD_IEEE754   0x080
#define GD_COMPLEX   0x100

typedef enum {
  GD_NULL       = 0,
  GD_UNKNOWN    = 0xfa0,  /* GD_SIZE(GD_UNKNOWN) MUST evaluate to zero */
  GD_UINT8      = GD_SIZE8,
  GD_INT8       = GD_SIZE8   | GD_SIGNED,
  GD_UINT16     = GD_SIZE16,
  GD_INT16      = GD_SIZE16  | GD_SIGNED,
  GD_UINT32     = GD_SIZE32,
  GD_INT32      = GD_SIZE32  | GD_SIGNED,
  GD_UINT64     = GD_SIZE64,
  GD_INT64      = GD_SIZE64  | GD_SIGNED,
  GD_FLOAT32    = GD_SIZE32  | GD_IEEE754,
  GD_FLOAT64    = GD_SIZE64  | GD_IEEE754,
  GD_COMPLEX64  = GD_SIZE64  | GD_COMPLEX,
  GD_COMPLEX128 = GD_SIZE128 | GD_COMPLEX
} gd_type_t;
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

struct _gd_private_entry;

/* Unified entry struct */
struct _gd_unified_entry {
  char *field;
  gd_entype_t field_type;
  char *in_fields[GD_MAX_LINCOM];
  char *scalar[GD_MAX_POLYORD + 1];
  int fragment_index;
  int comp_scal;
  union {
    struct { /* RAW */
      gd_spf_t spf;
      gd_type_t type;
    } raw;
    struct { /* LINCOM */
      int n_fields;
      double m[GD_MAX_LINCOM];
      GD_DCOMPLEXM(cm[GD_MAX_LINCOM]);
      double b[GD_MAX_LINCOM];
      GD_DCOMPLEXM(cb[GD_MAX_LINCOM]);
    } lincom;
    struct { /* LINTERP */
      char *table;
    } linterp;
    struct { /* BIT and SBIT */
      gd_bit_t bitnum;
      gd_bit_t numbits;
    } bit;
    struct { /* PHASE */
      gd_shift_t shift;
    } phase;
    struct { /* CONST */
      gd_type_t type;
    } cons;
    struct { /* POLYNOM */
      int poly_ord;
      double a[GD_MAX_POLYORD + 1];
      GD_DCOMPLEXM(ca[GD_MAX_POLYORD + 1]);
    } polynom;
    struct { /* RECIP */
      double dividend;
      GD_DCOMPLEXM(cdividend);
    } recip;
  } u;

  struct _gd_private_entry *e;
};

typedef struct _gd_unified_entry gd_entry_t;

/* The dirifle object */
typedef struct _GD_DIRFILE DIRFILE;

/* Parser callback objects */
struct _gd_callback_data {
  const DIRFILE* dirfile;
  int suberror;
  int linenum;
  const char* filename;
  char* line;
};

typedef struct _gd_callback_data gd_parser_data_t;

typedef int (*gd_parser_callback_t)(gd_parser_data_t*, void*);


/* dirfile_flags --- 0xF0000000 are reserved */
#define GD_ACCMODE        0x00000001 /* mask */
#define GD_RDONLY         0x00000000 /* open read only */
#define GD_RDWR           0x00000001 /* open read/write */

#define GD_FORCE_ENDIAN   0x00000002 /* override endianness */
#define GD_BIG_ENDIAN     0x00000004 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN  0x00000008 /* assume litte-endian raw data */
#define GD_CREAT          0x00000010 /* create dirfile if it doesn't exist */
#define GD_EXCL           0x00000020 /* force creation: fail on existence */
#define GD_TRUNC          0x00000040 /* truncate dirfile (scary!) */
#define GD_PEDANTIC       0x00000080 /* be pedantic */
#define GD_FORCE_ENCODING 0x00000100 /* override encoding scheme */
#define GD_VERBOSE        0x00000200 /* be verbose */
#define GD_IGNORE_DUPS    0x00000400 /* ignore duplicate fields */
#define GD_IGNORE_REFS    0x00000800 /* ignore REFERENCE directives --
                                        dirfile_include only */
#define GD_PRETTY_PRINT   0x00001000 /* make a nicer looking format file */
#define GD_ARM_ENDIAN     0x00002000 /* ARM-endian doubles */
#define GD_PERMISSIVE     0x00004000 /* be permissive */

#define GD_ENCODING       0x0F000000 /* mask */
#define GD_AUTO_ENCODED   0x00000000 /* Encoding scheme unknown */
#define GD_UNENCODED      0x01000000 /* Dirfile is not encoded */
#define GD_TEXT_ENCODED   0x02000000 /* Dirfile is text encoded */
#define GD_SLIM_ENCODED   0x03000000 /* Dirfile is slimlib encoded */
#define GD_GZIP_ENCODED   0x04000000 /* Dirfile is gzip encoded */
#define GD_BZIP2_ENCODED  0x05000000 /* Dirfile is bzip2 encoded */
#define GD_LZMA_ENCODED   0x06000000 /* Dirfile is xz encoded */
#define GD_ENC_UNSUPPORTED GD_ENCODING /* Dirfile encoding unsupported */

/* delete flags */
#define GD_DEL_META  0x1
#define GD_DEL_DATA  0x2
#define GD_DEL_DEREF 0x4
#define GD_DEL_FORCE 0x8

extern int gd_add_bit(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_bit_t bitnum, gd_bit_t numbits, int fragment_index)
gd_nothrow gd_nonnull ((1,2,3));

extern int gd_add_clincom(DIRFILE *dirfile, const char *field_code,
    int n_fields, const char **in_fields, const GD_DCOMPLEXP(cm),
    const GD_DCOMPLEXP(cb), int fragment_index) gd_nothrow
gd_nonnull ((1,2,4,5,6));

extern int gd_add_const(DIRFILE *dirfile, const char *field_code,
    gd_type_t const_type, gd_type_t data_type, const void* value,
    int fragment_index) gd_nothrow gd_nonnull ((1,2,5));

extern int gd_add_cpolynom(DIRFILE *dirfile, const char *field_code,
    int poly_ord, const char *in_field, const GD_DCOMPLEXP(ca),
    int fragment_index) gd_nothrow gd_nonnull ((1,2,4));

/* The native gd_add_crecip cannot be used in C89 mode */
#if ! defined GD_C89_API && ! defined GD_NO_C99_API
extern int gd_add_crecip(DIRFILE *dirfile, const char *field_code,
    const char *in_field, _Complex double cdividend, int fragment_index)
  gd_nothrow gd_nonnull ((1,2,3));
#else
#define gd_add_crecip gd_add_crecip89
#endif

extern int gd_add_crecip89(DIRFILE *dirfile, const char *field_code,
    const char *in_field, const double cdividend[2], int fragment_index)
  gd_nothrow gd_nonnull ((1,2,3));

extern int gd_add_divide(DIRFILE *dirfile, const char *field_code,
    const char *in_field1, const char *in_field2, int fragment_index)
gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_add_lincom(DIRFILE *dirfile, const char *field_code, int n_fields,
    const char **in_fields, const double *m, const double *b,
    int fragment_index) gd_nothrow gd_nonnull ((1,2,4,5,6));

extern int gd_add_linterp(DIRFILE *dirfile, const char *field_code,
    const char *in_field, const char *table, int fragment_index) gd_nothrow
gd_nonnull ((1,2,3,4));

extern int gd_add_multiply(DIRFILE *dirfile, const char *field_code,
    const char *in_field1, const char *in_field2, int fragment_index)
gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_add_phase(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_shift_t shift, int fragment_index) gd_nothrow
gd_nonnull ((1,2,3));

extern int gd_add_polynom(DIRFILE *dirfile, const char *field_code,
    int poly_ord, const char *in_field, const double *a, int fragment_index)
gd_nothrow gd_nonnull ((1,2,4));

extern int gd_add_recip(DIRFILE *dirfile, const char *field_code,
    const char *in_field, double dividend, int fragment_index) gd_nothrow
gd_nonnull ((1,2,3));

extern int gd_add_sbit(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_bit_t bitnum, gd_bit_t numbits,
    int fragment_index) gd_nothrow gd_nonnull ((1,2,3));

extern int gd_add_string(DIRFILE *dirfile, const char *field_code,
    const char *value, int fragment_index) gd_nothrow gd_nonnull((1,2,3));

extern int gd_alter_bit(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_bit_t bitnum, gd_bit_t numbits) gd_nothrow
gd_nonnull((1,2));

extern int gd_alter_clincom(DIRFILE *dirfile, const char *field_code,
    int n_fields, const char **in_fields, const GD_DCOMPLEXP(m),
    const GD_DCOMPLEXP(b)) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_const(DIRFILE *dirfile, const char *field_code,
    gd_type_t const_type) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_cpolynom(DIRFILE *dirfile, const char *field_code,
    int poly_ord, const char *in_field, const GD_DCOMPLEXP(a)) gd_nothrow
gd_nonnull((1,2));

#if ! defined GD_C89_API && ! defined GD_NO_C99_API
extern int gd_alter_crecip(DIRFILE *dirfile, const char *field_code,
    const char *in_field, _Complex double cdividend) gd_nothrow
gd_nonnull((1,2));
#else
#define gd_alter_crecip gd_alter_crecip89
#endif

extern int gd_alter_crecip89(DIRFILE *dirfile, const char *field_code,
    const char *in_field, const double cdividend[2]) gd_nothrow
gd_nonnull((1,2));

extern int gd_alter_divide(DIRFILE *dirfile, const char *field_code,
    const char *in_field1, const char *in_field2) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_lincom(DIRFILE *dirfile, const char *field_code,
    int n_fields, const char **in_fields, const double *m, const double *b)
gd_nothrow gd_nonnull((1,2));

extern int gd_alter_multiply(DIRFILE *dirfile, const char *field_code,
    const char *in_field1, const char *in_field2) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_phase(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_shift_t shift) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_polynom(DIRFILE *dirfile, const char *field_code,
    int poly_ord, const char *in_field, const double *a) gd_nothrow
gd_nonnull((1,2));

extern int gd_alter_recip(DIRFILE *dirfile, const char *field_code,
    const char *in_field, double cdividend) gd_nothrow gd_nonnull((1,2));

extern int gd_alter_sbit(DIRFILE *dirfile, const char *field_code,
    const char *in_field, gd_bit_t bitnum, gd_bit_t numbits) gd_nothrow
gd_nonnull((1,2));

extern int gd_get_constant(DIRFILE *dirfile, const char *field_code,
    gd_type_t return_type, void *data) gd_nothrow gd_nonnull ((1, 2));

extern int gd_put_constant(DIRFILE *dirfile, const char *field_code,
    gd_type_t data_type, const void *data) gd_nothrow gd_nonnull ((1, 2, 4));

extern const void *gd_constants(DIRFILE *dirfile,
    gd_type_t return_type) gd_nothrow gd_nonnull ((1));

extern gd_entry_t *gd_free_entry_strings(gd_entry_t *entry) gd_nothrow;

extern unsigned long int gd_encoding(DIRFILE *dirfile,
    int fragment) gd_nothrow gd_nonnull ((1));

extern unsigned long int gd_endianness(DIRFILE *dirfile,
    int fragment) gd_nothrow gd_nonnull((1));

extern int gd_entry(DIRFILE *dirfile, const char *field_code,
    gd_entry_t *entry) gd_nothrow gd_nonnull ((1, 2));

extern gd_entype_t gd_entry_type(DIRFILE *dirfile,
    const char *field_code) gd_nothrow gd_nonnull ((1));

extern int gd_error(const DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern char *gd_error_string(const DIRFILE *dirfile, char *buffer,
    size_t buflen) gd_nothrow gd_nonnull ((1, 2));

extern const char **gd_field_list(DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern const char **gd_field_list_by_type(DIRFILE *dirfile,
    gd_entype_t type) gd_nothrow gd_nonnull ((1));

extern int gd_fragment_index(DIRFILE *dirfile,
    const char *field_code) gd_nothrow gd_nonnull ((1));

extern const char *gd_fragmentname(DIRFILE *dirfile,
    int index) gd_nothrow gd_nonnull ((1));

extern int gd_madd(DIRFILE *dirfile, const gd_entry_t *entry,
    const char *parent) gd_nothrow gd_nonnull ((1,2,3));

extern int gd_madd_bit(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, gd_bit_t bitnum,
    gd_bit_t numbits) gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_madd_clincom(DIRFILE *dirfile, const char *parent,
    const char *field_code, int n_fields, const char **in_fields,
    const GD_DCOMPLEXP(cm), const GD_DCOMPLEXP(cb)) gd_nothrow
gd_nonnull((1,2,3,5,6,7));

extern int gd_madd_const(DIRFILE *dirfile, const char *parent,
    const char *field_code, gd_type_t const_type, gd_type_t data_type,
    const void *value) gd_nothrow gd_nonnull ((1,2,3,6));

extern int gd_madd_cpolynom(DIRFILE *dirfile, const char *parent,
    const char *field_code, int poly_ord, const char *in_field,
    const GD_DCOMPLEXP(ca)) gd_nothrow gd_nonnull ((1,2,3,5));

#if ! defined GD_C89_API && ! defined GD_NO_C99_API
extern int gd_madd_crecip(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, _Complex double cdividend)
gd_nothrow gd_nonnull ((1,2,3,4));
#else
#define gd_madd_crecip gd_madd_crecip89
#endif

extern int gd_madd_crecip89(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, const double cdividend[2])
gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_madd_divide(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field1, const char *in_field2)
gd_nothrow gd_nonnull ((1,2,3,4,5));

extern int gd_madd_lincom(DIRFILE *dirfile, const char *parent,
    const char *field_code, int n_fields, const char **in_fields,
    const double *m, const double *b) gd_nothrow gd_nonnull((1,2,3,5,6,7));

extern int gd_madd_linterp(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, const char *table)
gd_nothrow gd_nonnull ((1,2,3,4,5));

extern int gd_madd_multiply(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field1, const char *in_field2)
gd_nothrow gd_nonnull ((1,2,3,4,5));

extern int gd_madd_phase(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, gd_shift_t shift)
gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_madd_polynom(DIRFILE *dirfile, const char *parent,
    const char *field_code, int poly_ord, const char *in_field, const double *a)
gd_nothrow gd_nonnull ((1,2,3,5));

extern int gd_madd_recip(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, double dividend) gd_nothrow
gd_nonnull ((1,2,3,4));

extern int gd_madd_sbit(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *in_field, gd_bit_t bitnum,
    gd_bit_t numbits) gd_nothrow gd_nonnull ((1,2,3,4));

extern int gd_madd_spec(DIRFILE *dirfile, const char *line,
    const char *parent) gd_nothrow gd_nonnull ((1,2,3));

extern int gd_madd_string(DIRFILE *dirfile, const char *parent,
    const char *field_code, const char *value) gd_nothrow
gd_nonnull ((1,2,3,4));

extern int gd_dirfile_standards(DIRFILE *D, int vers) gd_nothrow
gd_nonnull ((1));

extern const void *gd_mconstants(DIRFILE *dirfile, const char *parent,
    gd_type_t return_type) gd_nothrow gd_nonnull((1,2));

extern const char **gd_mfield_list(DIRFILE *dirfile,
    const char *parent) gd_nothrow gd_nonnull((1,2));

extern const char **gd_mfield_list_by_type(DIRFILE *dirfile,
    const char *parent, gd_entype_t type) gd_nothrow gd_nonnull((1,2));

extern const char **gd_mstrings(DIRFILE *dirfile, const char *parent) gd_nothrow
gd_nonnull((1,2));

extern const char **gd_mvector_list(DIRFILE *dirfile,
    const char *parent) gd_nothrow gd_nonnull((1,2));

extern const char *gd_dirfilename(DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern gd_type_t gd_native_type(DIRFILE *dirfile,
    const char *field_code_in) gd_nothrow gd_nonnull ((1,2));

extern unsigned int gd_nfields(DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern unsigned int gd_nfields_by_type(DIRFILE *dirfile,
    gd_entype_t type) gd_nothrow gd_nonnull ((1));

extern int gd_nfragments(DIRFILE *dirfile) gd_nothrow gd_nonnull((1));

extern unsigned int gd_nmfields(DIRFILE *dirfile, const char *parent) gd_nothrow
gd_nonnull((1,2));

extern unsigned int gd_nmfields_by_type(DIRFILE *dirfile, const char *parent,
    gd_entype_t type) gd_nothrow gd_nonnull((1,2));

extern unsigned int gd_nmvectors(DIRFILE *dirfile,
    const char *parent) gd_nothrow gd_nonnull((1,2));

extern unsigned int gd_nvectors(DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern int gd_parent_fragment(DIRFILE *dirfile, int fragment_index) gd_nothrow
gd_nonnull ((1));

extern void gd_parser_callback(DIRFILE *dirfile, gd_parser_callback_t sehandler,
    void*) gd_nothrow gd_nonnull ((1));

extern int gd_alter_protection(DIRFILE *dirfile, int protection_level,
    int fragment_index) gd_nothrow gd_nonnull ((1));

extern int gd_protection(DIRFILE *dirfile, int fragment_index) gd_nothrow
gd_nonnull ((1));

extern const char *gd_raw_filename(DIRFILE *dirfile,
    const char *field_code) gd_nothrow gd_nonnull ((1, 2));

extern const char *gd_reference(DIRFILE *dirfile,
    const char *field_code) gd_nothrow gd_nonnull ((1));

extern gd_spf_t gd_spf(DIRFILE *dirfile, const char *field_code) gd_nothrow
gd_nonnull ((1, 2));

extern size_t gd_get_string(DIRFILE *dirfile, const char *field_code,
    size_t len, char *data) gd_nothrow gd_nonnull ((1, 2, 4));

extern size_t gd_put_string(DIRFILE *dirfile, const char *field_code,
    const char *data) gd_nothrow gd_nonnull ((1, 2, 3));

extern const char **gd_strings(DIRFILE *dirfile) gd_nothrow gd_nonnull ((1));

extern int gd_validate(DIRFILE *dirfile, const char *field_code_in) gd_nothrow
gd_nonnull((1,2));

extern const char **gd_vector_list(DIRFILE *dirfile) gd_nothrow gd_nonnull((1));

/* The following functions contain calls to I/O functions, making them
 * cancellation points.  As a result we cannot mark them with gd_nothrow.
 */
extern int gd_add(DIRFILE *dirfile, const gd_entry_t *entry) gd_nonnull((1,2));

extern int gd_add_raw(DIRFILE *dirfile, const char *field_code,
    gd_type_t data_type, gd_spf_t spf, int fragment_index) gd_nonnull((1,2));

extern int gd_add_spec(DIRFILE *dirfile, const char *line,
    int fragment_index) gd_nonnull ((1,2));

extern int gd_alter_encoding(DIRFILE *dirfile, unsigned long int encoding,
    int fragment, int recode) gd_nonnull ((1));

extern int gd_alter_endianness(DIRFILE *dirfile, unsigned long int byte_sex,
    int fragment, int recode) gd_nonnull ((1));

extern int gd_alter_entry(DIRFILE *dirfile, const char *field_code,
    const gd_entry_t *entry, int recode) gd_nonnull ((1,2));

extern int gd_alter_linterp(DIRFILE *dirfile, const char *field_code,
    const char *in_field, const char *table, int recode) gd_nonnull ((1,2));

extern int gd_alter_raw(DIRFILE *dirfile, const char *field_code,
    gd_type_t data_type, gd_spf_t spf, int recode) gd_nonnull ((1,2));

extern int gd_alter_spec(DIRFILE *dirfile, const char *line,
    int recode) gd_nonnull ((1,2));

extern DIRFILE *gd_cbopen(const char *dirfilename, unsigned long int flags,
    gd_parser_callback_t sehandler, void* extra) gd_nonnull ((1));

extern int gd_close(DIRFILE *dirfile);

extern int gd_delete(DIRFILE *dirfile, const char *field_code,
    int flags) gd_nonnull ((1,2));

extern int gd_discard(DIRFILE *dirfile);

extern int gd_flush(DIRFILE *dirfile, const char *field_code) gd_nonnull ((1));

extern int gd_include(DIRFILE *dirfile, const char *file, int fragment_index,
    unsigned long int flags) gd_nonnull ((1,2));

double gd_framenum(DIRFILE* D, const char* field_code_in,
    double value) gd_nonnull ((1,2));

extern int gd_malter_spec(DIRFILE *dirfile, const char *line,
    const char *parent, int recode) gd_nonnull ((1,2,3));

extern int gd_metaflush(DIRFILE *dirfile) gd_nonnull ((1));

extern int gd_move(DIRFILE *dirfile, const char *field_code, int new_fragment,
    int move_data) gd_nonnull ((1,2));

extern DIRFILE *gd_open(const char *dirfilename,
    unsigned long int flags) gd_nonnull ((1));

extern int gd_rename(DIRFILE *dirfile, const char *old_code,
    const char *new_name, int move_data) gd_nonnull ((1,2,3));

extern int gd_rewrite_fragment(DIRFILE *dirfile, int fragment) gd_nonnull ((1));

extern int gd_uninclude(DIRFILE *dirfile, int fragment_index,
    int del) gd_nonnull ((1));

/* the following functions are _FILE_OFFSET_BITS sensitive */
#if !defined _FILE_OFFSET_BITS || _FILE_OFFSET_BITS != 64
extern int gd_alter_frameoffset(DIRFILE *dirfile, off_t offset, int fragment,
    int recode) gd_nonnull ((1));

extern size_t gd_getdata(DIRFILE *dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t return_type, void *data) gd_nonnull ((1, 2));

extern size_t gd_putdata(DIRFILE *dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type, const void *data)
gd_nonnull ((1, 2));

extern double gd_framenum_subset(DIRFILE* D, const char* field_code,
    double value, off_t field_start, off_t field_end) gd_nonnull ((1,2));

extern off_t gd_frameoffset(DIRFILE *dirfile, int fragment) gd_nothrow
gd_nonnull ((1));

extern off_t gd_nframes(DIRFILE *dirfile) gd_nonnull ((1));

extern off_t gd_bof(DIRFILE *dirfile, const char* field_code) gd_nothrow
gd_nonnull ((1,2));

extern off_t gd_eof(DIRFILE *dirfile, const char* field_code)
  gd_nonnull ((1,2));
#else
# ifdef __REDIRECT_NTH
extern off_t __REDIRECT_NTH (gd_bof, (DIRFILE *dirfile, const char* field_code),
    gd_bof64) gd_nonnull ((1,2));

extern off_t __REDIRECT_NTH (gd_frameoffset, (DIRFILE *dirfile, int fragment),
    gd_frameoffset64) gd_nonnull ((1));
# else
#  define gd_bof gd_bof64
#  define gd_frameoffset gd_frameoffset64
# endif

# ifdef __REDIRECT
extern int __REDIRECT (gd_alter_frameoffset, (DIRFILE *dirfile, off_t offset,
      int fragment, int recode), gd_alter_frameoffset64) gd_nonnull ((1));

extern size_t __REDIRECT (gd_getdata, (DIRFILE *dirfile, const char *field_code,
      off_t first_frame, off_t first_samp, size_t num_frames, size_t num_samp,
      gd_type_t return_type, void *data), gd_getdata64) gd_nonnull ((1, 2));

extern size_t __REDIRECT (gd_putdata, (DIRFILE *dirfile, const char *field_code,
      off_t first_frame, off_t first_sample, size_t num_frames,
      size_t num_samples, gd_type_t data_type, const void *data),
    gd_putdata64) gd_nonnull ((1, 2));

extern off_t __REDIRECT (gd_nframes, (DIRFILE *dirfile),
    gd_nframes64) gd_nonnull ((1));

extern off_t __REDIRECT (gd_eof, (DIRFILE *dirfile, const char* field_code),
    gd_eof64) gd_nonnull ((1,2));

extern double __REDIRECT (gd_framenum_subset, (DIRFILE* D,
      const char* field_code, double value, off_t field_start, off_t field_end),
    gd_framenum_subset64) gd_nonnull ((1,2));
# else
#  define gd_alter_frameoffset gd_alter_frameoffset64
#  define gd_getdata gd_getdata64
#  define gd_putdata gd_putdata64
#  define gd_nframes gd_nframes64
#  define gd_eof gd_eof64
#  define gd_framenum_subset gd_framenum_subset64
# endif
#endif

/* if required, declare the LFS transitional extension */
#if defined _LARGEFILE64_SOURCE || (defined _FILE_OFFSET_BITS && \
    _FILE_OFFSET_BITS == 64) || (defined __CYGWIN__) || (defined __APPLE__)

#if (defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64) || \
                                    (defined __APPLE__) || (defined __CYGWIN__)
#define off64_t off_t
#endif
extern int gd_alter_frameoffset64(DIRFILE *dirfile, off64_t offset,
    int fragment, int recode) gd_nonnull ((1));

extern size_t gd_getdata64(DIRFILE *dirfile, const char *field_code,
    off64_t first_frame, off64_t first_samp, size_t num_frames, size_t num_samp,
    gd_type_t return_type, void *data) gd_nonnull ((1, 2));

extern size_t gd_putdata64(DIRFILE *dirfile, const char *field_code,
    off64_t first_frame, off64_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type, const void *data)
gd_nonnull ((1, 2));

extern off64_t gd_frameoffset64(DIRFILE *dirfile, int fragment) gd_nonnull((1));

extern double gd_framenum_subset64(DIRFILE* D, const char* field_code_in,
    double value, off64_t field_start, off64_t field_end) gd_nonnull ((1,2));

extern off64_t gd_nframes64(DIRFILE *dirfile) gd_nonnull ((1));

extern off64_t gd_bof64(DIRFILE *dirfile, const char* field_code) gd_nothrow
gd_nonnull ((1,2));

extern off64_t gd_eof64(DIRFILE *dirfile, const char* field_code)
  gd_nonnull ((1,2));

#if (defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64) || \
                                    (defined __APPLE__) || (defined __CYGWIN__)
#undef off64_t
#endif
#endif


/* If this symbol is defined here, the legacy API is present in the library */
#undef GD_LEGACY_API

#ifdef __cplusplus
}
#endif

/* The caller can disable the legacy API by defining GD_NO_LEGACY_API
 * before including getdata.h
 */
#ifndef GD_NO_LEGACY_API
/* include the legacy api, if present */
#  ifdef GD_LEGACY_API
#    include <getdata_legacy.h>
#  endif
#endif

/* function aliases */
#ifdef GD_FUNCTION_ALIASES
#  define dirfile_add gd_add
#  define dirfile_add_bit gd_add_bit
#  define dirfile_add_clincom gd_add_clincom
#  define dirfile_add_const gd_add_const
#  define dirfile_add_cpolynom gd_add_cpolynom
#  define dirfile_add_lincom gd_add_lincom
#  define dirfile_add_linterp gd_add_linterp
#  define dirfile_add_multiply gd_add_multiply
#  define dirfile_add_phase gd_add_phase
#  define dirfile_add_polynom gd_add_polynom
#  define dirfile_add_raw gd_add_raw
#  define dirfile_add_sbit gd_add_sbit
#  define dirfile_add_spec gd_add_spec
#  define dirfile_add_string gd_add_string
#  define dirfile_alter_bit gd_alter_bit
#  define dirfile_alter_clincom gd_alter_clincom
#  define dirfile_alter_const gd_alter_const
#  define dirfile_alter_cpolynom gd_alter_cpolynom
#  define dirfile_alter_encoding gd_alter_encoding
#  define dirfile_alter_endianness gd_alter_endianness
#  define dirfile_alter_entry gd_alter_entry
#  define dirfile_alter_frameoffset gd_alter_frameoffset
#  define dirfile_alter_frameoffset64 gd_alter_frameoffset64
#  define dirfile_alter_lincom gd_alter_lincom
#  define dirfile_alter_linterp gd_alter_linterp
#  define dirfile_alter_multiply gd_alter_multiply
#  define dirfile_alter_phase gd_alter_phase
#  define dirfile_alter_polynom gd_alter_polynom
#  define dirfile_alter_raw gd_alter_raw
#  define dirfile_alter_sbit gd_alter_sbit
#  define dirfile_alter_spec gd_alter_spec
#  define dirfile_cbopen gd_cbopen
#  define dirfile_close gd_close
#  define get_constant gd_get_constant
#  define put_constant gd_put_constant
#  define get_constants gd_constants
#  define getdata gd_getdata
#  define putdata gd_putdata
#  define getdata64 gd_getdata64
#  define putdata64 gd_putdata64
#  define dirfile_delete gd_delete
#  define dirfile_discard gd_discard
#  define get_encoding gd_encoding
#  define get_endianness gd_endianness
#  define get_entry gd_entry
#  define get_entry_type gd_entry_type
#  define get_error gd_error
#  define get_error_string gd_error_string
#  define get_field_list gd_field_list
#  define get_field_list_by_type gd_field_list_by_type
#  define dirfile_flush gd_flush
#  define get_fragment_index gd_fragment_index
#  define get_fragmentname gd_fragmentname
#  define get_framenum_subset gd_framenum_subset
#  define get_framenum_subset64 gd_framenum_subset64
#  define get_frameoffset gd_frameoffset
#  define get_frameoffset64 gd_frameoffset64
#  define dirfile_free_entry_strings gd_free_entry_strings
#  define dirfile_include gd_include
#  define dirfile_madd gd_madd
#  define dirfile_madd_bit gd_madd_bit
#  define dirfile_madd_clincom gd_madd_clincom
#  define dirfile_madd_const gd_madd_const
#  define dirfile_madd_cpolynom gd_madd_cpolynom
#  define dirfile_madd_lincom gd_madd_lincom
#  define dirfile_madd_linterp gd_madd_linterp
#  define dirfile_madd_multiply gd_madd_multiply
#  define dirfile_madd_phase gd_madd_phase
#  define dirfile_madd_polynom gd_madd_polynom
#  define dirfile_madd_sbit gd_madd_sbit
#  define dirfile_madd_spec gd_madd_spec
#  define dirfile_madd_string gd_madd_string
#  define dirfile_malter_spec gd_malter_spec
#  define get_mconstants gd_mconstants
#  define dirfile_metaflush gd_metaflush
#  define get_mfield_list gd_mfield_list
#  define get_mfield_list_by_type gd_mfield_list_by_type
#  define dirfile_move gd_move
#  define get_mstrings gd_mstrings
#  define get_mvector_list gd_mvector_list
#  define dirfilename gd_dirfilename
#  define get_native_type gd_native_type
#  define get_nfields gd_nfields
#  define get_nfields_by_type gd_nfields_by_type
#  define get_nfragments gd_nfragments
#  define get_nframes gd_nframes
#  define get_nframes64 gd_nframes64
#  define get_nmfields gd_nmfields
#  define get_nmfields_by_type gd_nmfields_by_type
#  define get_nmvectors gd_nmvectors
#  define get_nvectors gd_nvectors
#  define dirfile_open gd_open
#  define get_parent_fragment gd_parent_fragment
#  define dirfile_parser_callback gd_parser_callback
#  define dirfile_protect gd_alter_protection
#  define get_protection gd_protection
#  define get_raw_filename gd_raw_filename
#  define dirfile_reference gd_reference
#  define get_reference(D) gd_reference(D,NULL)
#  define dirfile_rename gd_rename
#  define get_spf gd_spf
#  define dirfile_standards gd_dirfile_standards
#  define get_string gd_get_string
#  define put_string gd_put_string
#  define get_strings gd_strings
#  define dirfile_uninclude gd_uninclude
#  define dirfile_validate gd_validate
#  define get_vector_list gd_vector_list
#endif

#endif
