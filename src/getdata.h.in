/* (C) 2002-2005 C. Barth Netterfield
 * (C) 2003-2005 Theodore Kisner
 * (C) 2005-2008 D. V. Wiebe
 *
 ***************************************************************************
 *
 * This file is part of the GetData project.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GetData is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with the GetData if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307 USA.
 */

#ifndef GETDATA_H
#define GETDATA_H

/* one or more of these should give us:
 *    size_t, off_t, __REDIRECT, &c. 
 */
#include <sys/types.h>
#include <unistd.h>

/* For FILENAME_MAX */
#include <stdio.h>

#define DIRFILE_STANDARDS_VERSION 5

/* ICC ignores the __nonnull__ attribute */
#ifdef __INTEL_COMPILER
# define __gd_nonnull(...)
#else
# define __gd_nonnull __nonnull
#endif

/* if these haven't been defined by the above includes, define them now */
#ifndef __attribute_deprecated__
# define __attribute_deprecated__
#endif
#ifndef __THROW
# define __THROW
#endif
#ifndef __nonnull
# define __nonnull(...)
#endif

/* error codes */
#define GD_E_OK                0 /* this must be zero */
#define GD_E_OPEN              1
#define GD_E_FORMAT            2
#define GD_E_TRUNC             3
#define GD_E_CREAT             4
#define GD_E_BAD_CODE          5
#define GD_E_BAD_TYPE          6
#define GD_E_RAW_IO            7
#define GD_E_OPEN_INCLUDE      8
#define GD_E_INTERNAL_ERROR    9
#define GD_E_EMPTY            10
#define GD_E_ALLOC            11
#define GD_E_RANGE            12
#define GD_E_OPEN_LINFILE     13
#define GD_E_RECURSE_LEVEL    14
#define GD_E_BAD_DIRFILE      15
#define GD_E_BAD_PUT_FIELD    16
#define GD_E_ACCMODE          17

#define GD_N_ERROR_CODES      18

#ifndef FILENAME_MAX
#  define FILENAME_MAX 4096
#endif
#define GD_MAX_LINCOM 3

/* field types */
#define GD_RAW_ENTRY      0
#define GD_LINCOM_ENTRY   1
#define GD_LINTERP_ENTRY  2
#define GD_BIT_ENTRY      3
#define GD_MULTIPLY_ENTRY 4
#define GD_PHASE_ENTRY    5

/* Data types -- No valid type may contain 0x40.  This will automatically
 * invalidate any attempt to use the old-style character types as gd_type_t's */
#define GD_SIZE8     0x01
#define GD_SIZE16    0x02
#define GD_SIZE32    0x04
#define GD_SIZE64    0x08
#define GD_SIZE(x)   (x & 0x0f)

#define GD_SIGNED    0x10
#define GD_IEEE754   0x20

typedef enum {
  GD_NULL    = 0,
  GD_UNKNOWN = 0xf0,  /* GD_SIZE(GD_UNKNOWN) must evaluate to zero */
  GD_UINT8   = GD_SIZE8,
  GD_INT8    = GD_SIZE8  | GD_SIGNED,
  GD_UINT16  = GD_SIZE16,
  GD_INT16   = GD_SIZE16 | GD_SIGNED,
  GD_UINT32  = GD_SIZE32,
  GD_INT32   = GD_SIZE32 | GD_SIGNED,
  GD_UINT64  = GD_SIZE64,
  GD_INT64   = GD_SIZE64 | GD_SIGNED,
  GD_FLOAT32 = GD_SIZE32 | GD_IEEE754,
  GD_FLOAT64 = GD_SIZE64 | GD_IEEE754
} gd_type_t;
#define GD_FLOAT     GD_FLOAT32
#define GD_DOUBLE    GD_FLOAT64

/* Unified entry struct */
struct _gd_unified_entry {
  char* field;
  int field_type;
  union {
    char* file;
    char *in_fields[GD_MAX_LINCOM];
  };
  union {
    int fp;
    int count;
    int bitnum;
    int shift;
  };
  union {
    unsigned int samples_per_frame;
    int numbits;
  };
  union {
    double* m;
    double* x;
    gd_type_t data_type;
  };
  union {
    double* b;
    double* y;
    size_t size;
  };
};

typedef struct _gd_unified_entry gd_entry_t;

/* The DIRFILE struct.  */
struct _GD_DIRFILE {
  /* Error reporting -- this is the only public member. */
  int error;

  /* Everything below this comment should be considered internal to the library
   * and not part of the official API */

  /* field count */
  unsigned int n_entries;

  /* field array */
  gd_entry_t** entries;

  /* The first field */
  gd_entry_t* first_field;

  /* directory name */
  const char* name;

  /* recursion counter */
  int recurse_level;

  int frame_offset;
  int suberror;
  char* error_string;
  char* error_file;
  int error_line;
  int flags;
};

typedef struct _GD_DIRFILE DIRFILE;

/* dirfile_flags */
#define GD_ACCMODE            03
#define GD_RDONLY             00 /* open read only */
#define GD_RDWR               02 /* open read/write */
#define GD_CREAT            0100 /* create the dirfile if it doesn't exist */
#define GD_EXCL             0200 /* force creation: fail on existence */
#define GD_TRUNC           01000 /* truncate dirfile (scary!) */
#define GD_BIG_ENDIAN    0200000 /* assume big-endian raw data */
#define GD_LITTLE_ENDIAN 0400000 /* assume litte-endian raw data */
#define GD_FORCE_ENDIAN 01000000 /* override endianness */
#define GD_PEDANTIC     02000000 /* be pedantic */
#define GD_INVALID      04000000 /* the dirfile is invalid */

extern char* getdata_error_string(const DIRFILE* dirfile, char* buffer,
    size_t buflen) __THROW __gd_nonnull ((1, 2));

extern void dirfile_close(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern unsigned int get_samples_per_frame(DIRFILE* dirfile,
    const char *field_code) __THROW __gd_nonnull ((1, 2));

/* dirfile_open(), getdata(), and putdata() contain calls to open(), making them
 * cancellation points.  As a result we cannot mark them with __THROW.
 */
extern DIRFILE* dirfile_open(const char* dirfilename,
    unsigned int flags) __gd_nonnull ((1));

/* the following functions are _FILE_OFFSET_BITS sensitive */
#ifndef __USE_FILE_OFFSET64
extern off_t get_n_frames(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t return_type,
    void *data_out) __gd_nonnull ((1, 2));

extern size_t putdata(DIRFILE* dirfile, const char *field_code,
    off_t first_frame, off_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#else
# ifdef __REDIRECT_NTH
extern off_t __REDIRECT_NTH (get_n_frames, (DIRFILE* dirfile), get_n_frames64);
# else
#  define get_n_frames get_n_frames64
# endif

# ifdef __REDIRECT
extern size_t __REDIRECT (getdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_samp, size_t num_frames,
      size_t num_samp, gd_type_t return_type, void *data_out),
    getdata64) __gd_nonnull ((1, 2));

extern size_t __REDIRECT (putdata, (DIRFILE* dirfile, const char *field_code,
      __off64_t first_frame, __off64_t first_sample, size_t num_frames,
      size_t num_samples, gd_type_t data_type, const void *data_in),
    putdata64) __gd_nonnull ((1, 2));
# else
#  define getdata getdata64
#  define putdata putdata64
# endif
#endif

/* if requested, declare the LFS transitional extension */
#ifdef __USE_LARGEFILE64
extern __off64_t get_n_frames64(DIRFILE* dirfile) __THROW __gd_nonnull ((1));

extern size_t getdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_samp, size_t num_frames,
    size_t num_samp, gd_type_t return_type, void *data_out)
__gd_nonnull ((1, 2));

extern size_t putdata64(DIRFILE* dirfile, const char *field_code,
    __off64_t first_frame, __off64_t first_sample, size_t num_frames,
    size_t num_samples, gd_type_t data_type,
    const void *data_in) __gd_nonnull ((1, 2));
#endif

/* If this symbol is defined here, the legacy API is present in the library */
#undef GETDATA_LEGACY_API

/* include the legacy api, if present */
#ifdef GETDATA_LEGACY_API
#include <getdata_legacy.h>
#endif

#endif
